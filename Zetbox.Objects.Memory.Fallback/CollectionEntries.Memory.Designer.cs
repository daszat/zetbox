// <autogenerated/>

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Xml;
using System.Xml.Serialization;
using System.Linq;

using Zetbox.API;
using Zetbox.DalProvider.Base.RelationWrappers;
using Zetbox.DalProvider.Base;
using Zetbox.DalProvider.Memory;

namespace Zetbox.App.Base
{
    // BEGIN Zetbox.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("CalculatedReference_dependsOn_InputProperties_RelationEntryMemoryImpl")]
    public class CalculatedReference_dependsOn_InputProperties_RelationEntryMemoryImpl : Zetbox.DalProvider.Memory.RelationEntryMemoryImpl<Zetbox.App.Base.CalculatedObjectReferenceProperty, Zetbox.App.Base.CalculatedObjectReferencePropertyMemoryImpl, Zetbox.App.Base.Property, Zetbox.App.Base.PropertyMemoryImpl>, CalculatedReference_dependsOn_InputProperties_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        [Obsolete]
        public CalculatedReference_dependsOn_InputProperties_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public CalculatedReference_dependsOn_InputProperties_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Zetbox.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ID");
                }
            }
        }
        private int _ID;
        // END Zetbox.Generator.Templates.Properties.IdProperty
        // BEGIN Zetbox.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ExportGuid;
                if (_ExportGuid == Guid.Empty) {
                    __result = _ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ExportGuid != value)
                {
                    var __oldValue = _ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    _ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }
        private Guid _ExportGuid;
        // END Zetbox.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("47595643-e8d0-48ef-82c7-2d24de8a784e");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Base.CalculatedObjectReferenceProperty)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Property)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Base.CalculatedObjectReferenceProperty; moduleNamespace=Zetbox.App.Base;
        // will get inverse collection for notifications for Inputs
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
		[System.Runtime.Serialization.IgnoreDataMember]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.App.Base.CalculatedObjectReferenceProperty A
        {
            get { return AImpl; }
            set { AImpl = (Zetbox.App.Base.CalculatedObjectReferencePropertyMemoryImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        private int? __fk_ACache;

        private int? _fk_A {
            get
            {
                return __fk_ACache;
            }
            set
            {
                __fk_ACache = value;
                // Recreate task to clear it's cache
                _triggerFetchATask = null;
            }
        }

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return _fk_A; }
			set { _fk_A = value; }
		}

        private Guid? _fk_guid_A = null;

        Zetbox.API.Async.ZbTask<Zetbox.App.Base.CalculatedObjectReferenceProperty> _triggerFetchATask;
        public Zetbox.API.Async.ZbTask<Zetbox.App.Base.CalculatedObjectReferenceProperty> TriggerFetchAAsync()
        {
            if (_triggerFetchATask != null) return _triggerFetchATask;

            if (_fk_A.HasValue)
                _triggerFetchATask = Context.FindAsync<Zetbox.App.Base.CalculatedObjectReferenceProperty>(_fk_A.Value);
            else
                _triggerFetchATask = new Zetbox.API.Async.ZbTask<Zetbox.App.Base.CalculatedObjectReferenceProperty>(Zetbox.API.Async.ZbTask.Synchron, () => null);

            return _triggerFetchATask;
        }

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Zetbox.App.Base.CalculatedObjectReferencePropertyMemoryImpl AImpl
        {
            get
            {
                return (Zetbox.App.Base.CalculatedObjectReferencePropertyMemoryImpl)TriggerFetchAAsync().Result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noops
                if ((value == null && _fk_A == null) || (value != null && value.ID == _fk_A))
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null)
                {
                    __oldValue.NotifyPropertyChanging("Inputs", null, null);
                }

                if (__newValue != null)
                {
                    __newValue.NotifyPropertyChanging("Inputs", null, null);
                }

                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                if (__oldValue != null)
                    __oldValue.OnInputsCollectionChanged();

                if (__newValue != null)
                    __newValue.OnInputsCollectionChanged();

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;
            }
        }
        // END Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Property; moduleNamespace=Zetbox.App.Base;
        // no inverse navigator handling
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
		[System.Runtime.Serialization.IgnoreDataMember]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.App.Base.Property B
        {
            get { return BImpl; }
            set { BImpl = (Zetbox.App.Base.PropertyMemoryImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        private int? __fk_BCache;

        private int? _fk_B {
            get
            {
                return __fk_BCache;
            }
            set
            {
                __fk_BCache = value;
                // Recreate task to clear it's cache
                _triggerFetchBTask = null;
            }
        }

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return _fk_B; }
			set { _fk_B = value; }
		}

        private Guid? _fk_guid_B = null;

        Zetbox.API.Async.ZbTask<Zetbox.App.Base.Property> _triggerFetchBTask;
        public Zetbox.API.Async.ZbTask<Zetbox.App.Base.Property> TriggerFetchBAsync()
        {
            if (_triggerFetchBTask != null) return _triggerFetchBTask;

            if (_fk_B.HasValue)
                _triggerFetchBTask = Context.FindAsync<Zetbox.App.Base.Property>(_fk_B.Value);
            else
                _triggerFetchBTask = new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Property>(Zetbox.API.Async.ZbTask.Synchron, () => null);

            return _triggerFetchBTask;
        }

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Zetbox.App.Base.PropertyMemoryImpl BImpl
        {
            get
            {
                return (Zetbox.App.Base.PropertyMemoryImpl)TriggerFetchBAsync().Result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noops
                if ((value == null && _fk_B == null) || (value != null && value.ID == _fk_B))
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;
            }
        }
        // END Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this._ExportGuid);
            binStream.Write(A != null ? A.ID : (int?)null);
            binStream.Write(B != null ? B.ID : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this._ExportGuid = binStream.ReadGuid();
            this._fk_A = binStream.ReadNullableInt32();
            this._fk_B = binStream.ReadNullableInt32();
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", _ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(A != null ? A.ExportGuid : (Guid?)null, xml, "A", "Zetbox.App.Base");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(B != null ? B.ExportGuid : (Guid?)null, xml, "B", "Zetbox.App.Base");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "|ExportGuid":
                this._ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "Zetbox.App.Base|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.Base|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(CalculatedReference_dependsOn_InputProperties_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (CalculatedReference_dependsOn_InputProperties_RelationEntryMemoryImpl)obj;
            var me = (CalculatedReference_dependsOn_InputProperties_RelationEntryMemoryImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                AImpl = (Zetbox.App.Base.CalculatedObjectReferencePropertyMemoryImpl)Context.FindPersistenceObject<Zetbox.App.Base.CalculatedObjectReferenceProperty>(_fk_guid_A.Value);
            else
            if (_fk_A.HasValue)
                AImpl = (Zetbox.App.Base.CalculatedObjectReferencePropertyMemoryImpl)Context.Find<Zetbox.App.Base.CalculatedObjectReferenceProperty>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_guid_B.HasValue)
                BImpl = (Zetbox.App.Base.PropertyMemoryImpl)Context.FindPersistenceObject<Zetbox.App.Base.Property>(_fk_guid_B.Value);
            else
            if (_fk_B.HasValue)
                BImpl = (Zetbox.App.Base.PropertyMemoryImpl)Context.Find<Zetbox.App.Base.Property>(_fk_B.Value);
            else
                BImpl = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }
    }
    // END Zetbox.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.Base
{
    // BEGIN Zetbox.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("DataType_implements_ImplementedInterfaces_RelationEntryMemoryImpl")]
    public class DataType_implements_ImplementedInterfaces_RelationEntryMemoryImpl : Zetbox.DalProvider.Memory.RelationEntryMemoryImpl<Zetbox.App.Base.DataType, Zetbox.App.Base.DataTypeMemoryImpl, Zetbox.App.Base.Interface, Zetbox.App.Base.InterfaceMemoryImpl>, DataType_implements_ImplementedInterfaces_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        [Obsolete]
        public DataType_implements_ImplementedInterfaces_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public DataType_implements_ImplementedInterfaces_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Zetbox.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ID");
                }
            }
        }
        private int _ID;
        // END Zetbox.Generator.Templates.Properties.IdProperty
        // BEGIN Zetbox.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ExportGuid;
                if (_ExportGuid == Guid.Empty) {
                    __result = _ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ExportGuid != value)
                {
                    var __oldValue = _ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    _ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }
        private Guid _ExportGuid;
        // END Zetbox.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("692c1064-37a2-4be3-a81e-4cb91f673aa3");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Base.DataType)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Interface)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Base.DataType; moduleNamespace=Zetbox.App.Base;
        // will get inverse collection for notifications for ImplementsInterfaces
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
		[System.Runtime.Serialization.IgnoreDataMember]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.App.Base.DataType A
        {
            get { return AImpl; }
            set { AImpl = (Zetbox.App.Base.DataTypeMemoryImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        private int? __fk_ACache;

        private int? _fk_A {
            get
            {
                return __fk_ACache;
            }
            set
            {
                __fk_ACache = value;
                // Recreate task to clear it's cache
                _triggerFetchATask = null;
            }
        }

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return _fk_A; }
			set { _fk_A = value; }
		}

        private Guid? _fk_guid_A = null;

        Zetbox.API.Async.ZbTask<Zetbox.App.Base.DataType> _triggerFetchATask;
        public Zetbox.API.Async.ZbTask<Zetbox.App.Base.DataType> TriggerFetchAAsync()
        {
            if (_triggerFetchATask != null) return _triggerFetchATask;

            if (_fk_A.HasValue)
                _triggerFetchATask = Context.FindAsync<Zetbox.App.Base.DataType>(_fk_A.Value);
            else
                _triggerFetchATask = new Zetbox.API.Async.ZbTask<Zetbox.App.Base.DataType>(Zetbox.API.Async.ZbTask.Synchron, () => null);

            return _triggerFetchATask;
        }

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Zetbox.App.Base.DataTypeMemoryImpl AImpl
        {
            get
            {
                return (Zetbox.App.Base.DataTypeMemoryImpl)TriggerFetchAAsync().Result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noops
                if ((value == null && _fk_A == null) || (value != null && value.ID == _fk_A))
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null)
                {
                    __oldValue.NotifyPropertyChanging("ImplementsInterfaces", null, null);
                }

                if (__newValue != null)
                {
                    __newValue.NotifyPropertyChanging("ImplementsInterfaces", null, null);
                }

                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                if (__oldValue != null)
                    __oldValue.OnImplementsInterfacesCollectionChanged();

                if (__newValue != null)
                    __newValue.OnImplementsInterfacesCollectionChanged();

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;
            }
        }
        // END Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Interface; moduleNamespace=Zetbox.App.Base;
        // no inverse navigator handling
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
		[System.Runtime.Serialization.IgnoreDataMember]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.App.Base.Interface B
        {
            get { return BImpl; }
            set { BImpl = (Zetbox.App.Base.InterfaceMemoryImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        private int? __fk_BCache;

        private int? _fk_B {
            get
            {
                return __fk_BCache;
            }
            set
            {
                __fk_BCache = value;
                // Recreate task to clear it's cache
                _triggerFetchBTask = null;
            }
        }

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return _fk_B; }
			set { _fk_B = value; }
		}

        private Guid? _fk_guid_B = null;

        Zetbox.API.Async.ZbTask<Zetbox.App.Base.Interface> _triggerFetchBTask;
        public Zetbox.API.Async.ZbTask<Zetbox.App.Base.Interface> TriggerFetchBAsync()
        {
            if (_triggerFetchBTask != null) return _triggerFetchBTask;

            if (_fk_B.HasValue)
                _triggerFetchBTask = Context.FindAsync<Zetbox.App.Base.Interface>(_fk_B.Value);
            else
                _triggerFetchBTask = new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Interface>(Zetbox.API.Async.ZbTask.Synchron, () => null);

            return _triggerFetchBTask;
        }

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Zetbox.App.Base.InterfaceMemoryImpl BImpl
        {
            get
            {
                return (Zetbox.App.Base.InterfaceMemoryImpl)TriggerFetchBAsync().Result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noops
                if ((value == null && _fk_B == null) || (value != null && value.ID == _fk_B))
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;
            }
        }
        // END Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this._ExportGuid);
            binStream.Write(A != null ? A.ID : (int?)null);
            binStream.Write(B != null ? B.ID : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this._ExportGuid = binStream.ReadGuid();
            this._fk_A = binStream.ReadNullableInt32();
            this._fk_B = binStream.ReadNullableInt32();
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", _ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(A != null ? A.ExportGuid : (Guid?)null, xml, "A", "Zetbox.App.Base");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(B != null ? B.ExportGuid : (Guid?)null, xml, "B", "Zetbox.App.Base");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "|ExportGuid":
                this._ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "Zetbox.App.Base|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.Base|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(DataType_implements_ImplementedInterfaces_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (DataType_implements_ImplementedInterfaces_RelationEntryMemoryImpl)obj;
            var me = (DataType_implements_ImplementedInterfaces_RelationEntryMemoryImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                AImpl = (Zetbox.App.Base.DataTypeMemoryImpl)Context.FindPersistenceObject<Zetbox.App.Base.DataType>(_fk_guid_A.Value);
            else
            if (_fk_A.HasValue)
                AImpl = (Zetbox.App.Base.DataTypeMemoryImpl)Context.Find<Zetbox.App.Base.DataType>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_guid_B.HasValue)
                BImpl = (Zetbox.App.Base.InterfaceMemoryImpl)Context.FindPersistenceObject<Zetbox.App.Base.Interface>(_fk_guid_B.Value);
            else
            if (_fk_B.HasValue)
                BImpl = (Zetbox.App.Base.InterfaceMemoryImpl)Context.Find<Zetbox.App.Base.Interface>(_fk_B.Value);
            else
                BImpl = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }
    }
    // END Zetbox.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.Base
{
    // BEGIN Zetbox.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("Identities_memberOf_Groups_RelationEntryMemoryImpl")]
    public class Identities_memberOf_Groups_RelationEntryMemoryImpl : Zetbox.DalProvider.Memory.RelationEntryMemoryImpl<Zetbox.App.Base.Identity, Zetbox.App.Base.IdentityMemoryImpl, Zetbox.App.Base.Group, Zetbox.App.Base.GroupMemoryImpl>, Identities_memberOf_Groups_RelationEntry
    {
        [Obsolete]
        public Identities_memberOf_Groups_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public Identities_memberOf_Groups_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Zetbox.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ID");
                }
            }
        }
        private int _ID;
        // END Zetbox.Generator.Templates.Properties.IdProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("3efb7ae8-ba6b-40e3-9482-b45d1c101743");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Base.Identity)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Group)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Base.Identity; moduleNamespace=Zetbox.App.Base;
        // will get inverse collection for notifications for Groups
        // PositionStorage=none;
        // Target not exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
		[System.Runtime.Serialization.IgnoreDataMember]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.App.Base.Identity A
        {
            get { return AImpl; }
            set { AImpl = (Zetbox.App.Base.IdentityMemoryImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        private int? __fk_ACache;

        private int? _fk_A {
            get
            {
                return __fk_ACache;
            }
            set
            {
                __fk_ACache = value;
                // Recreate task to clear it's cache
                _triggerFetchATask = null;
            }
        }

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return _fk_A; }
			set { _fk_A = value; }
		}


        Zetbox.API.Async.ZbTask<Zetbox.App.Base.Identity> _triggerFetchATask;
        public Zetbox.API.Async.ZbTask<Zetbox.App.Base.Identity> TriggerFetchAAsync()
        {
            if (_triggerFetchATask != null) return _triggerFetchATask;

            if (_fk_A.HasValue)
                _triggerFetchATask = Context.FindAsync<Zetbox.App.Base.Identity>(_fk_A.Value);
            else
                _triggerFetchATask = new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Identity>(Zetbox.API.Async.ZbTask.Synchron, () => null);

            return _triggerFetchATask;
        }

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Zetbox.App.Base.IdentityMemoryImpl AImpl
        {
            get
            {
                return (Zetbox.App.Base.IdentityMemoryImpl)TriggerFetchAAsync().Result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noops
                if ((value == null && _fk_A == null) || (value != null && value.ID == _fk_A))
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null)
                {
                    __oldValue.NotifyPropertyChanging("Groups", null, null);
                }

                if (__newValue != null)
                {
                    __newValue.NotifyPropertyChanging("Groups", null, null);
                }

                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                if (__oldValue != null)
                    __oldValue.OnGroupsCollectionChanged();

                if (__newValue != null)
                    __newValue.OnGroupsCollectionChanged();

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;
            }
        }
        // END Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Group; moduleNamespace=Zetbox.App.Base;
        // will get inverse collection for notifications for Member
        // PositionStorage=none;
        // Target not exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
		[System.Runtime.Serialization.IgnoreDataMember]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.App.Base.Group B
        {
            get { return BImpl; }
            set { BImpl = (Zetbox.App.Base.GroupMemoryImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        private int? __fk_BCache;

        private int? _fk_B {
            get
            {
                return __fk_BCache;
            }
            set
            {
                __fk_BCache = value;
                // Recreate task to clear it's cache
                _triggerFetchBTask = null;
            }
        }

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return _fk_B; }
			set { _fk_B = value; }
		}


        Zetbox.API.Async.ZbTask<Zetbox.App.Base.Group> _triggerFetchBTask;
        public Zetbox.API.Async.ZbTask<Zetbox.App.Base.Group> TriggerFetchBAsync()
        {
            if (_triggerFetchBTask != null) return _triggerFetchBTask;

            if (_fk_B.HasValue)
                _triggerFetchBTask = Context.FindAsync<Zetbox.App.Base.Group>(_fk_B.Value);
            else
                _triggerFetchBTask = new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Group>(Zetbox.API.Async.ZbTask.Synchron, () => null);

            return _triggerFetchBTask;
        }

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Zetbox.App.Base.GroupMemoryImpl BImpl
        {
            get
            {
                return (Zetbox.App.Base.GroupMemoryImpl)TriggerFetchBAsync().Result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noops
                if ((value == null && _fk_B == null) || (value != null && value.ID == _fk_B))
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                if (__oldValue != null)
                {
                    __oldValue.NotifyPropertyChanging("Member", null, null);
                }

                if (__newValue != null)
                {
                    __newValue.NotifyPropertyChanging("Member", null, null);
                }

                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                if (__oldValue != null)
                    __oldValue.OnMemberCollectionChanged();

                if (__newValue != null)
                    __newValue.OnMemberCollectionChanged();

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;
            }
        }
        // END Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(A != null ? A.ID : (int?)null);
            binStream.Write(B != null ? B.ID : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this._fk_A = binStream.ReadNullableInt32();
            this._fk_B = binStream.ReadNullableInt32();
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Identities_memberOf_Groups_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Identities_memberOf_Groups_RelationEntryMemoryImpl)obj;
            var me = (Identities_memberOf_Groups_RelationEntryMemoryImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_A.HasValue)
                AImpl = (Zetbox.App.Base.IdentityMemoryImpl)Context.Find<Zetbox.App.Base.Identity>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_B.HasValue)
                BImpl = (Zetbox.App.Base.GroupMemoryImpl)Context.Find<Zetbox.App.Base.Group>(_fk_B.Value);
            else
                BImpl = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }
    }
    // END Zetbox.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.GUI
{
    // BEGIN Zetbox.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("NavigationScreen_accessed_by_Groups_RelationEntryMemoryImpl")]
    public class NavigationScreen_accessed_by_Groups_RelationEntryMemoryImpl : Zetbox.DalProvider.Memory.RelationEntryMemoryImpl<Zetbox.App.GUI.NavigationEntry, Zetbox.App.GUI.NavigationEntryMemoryImpl, Zetbox.App.Base.Group, Zetbox.App.Base.GroupMemoryImpl>, NavigationScreen_accessed_by_Groups_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        [Obsolete]
        public NavigationScreen_accessed_by_Groups_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public NavigationScreen_accessed_by_Groups_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Zetbox.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ID");
                }
            }
        }
        private int _ID;
        // END Zetbox.Generator.Templates.Properties.IdProperty
        // BEGIN Zetbox.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ExportGuid;
                if (_ExportGuid == Guid.Empty) {
                    __result = _ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ExportGuid != value)
                {
                    var __oldValue = _ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    _ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }
        private Guid _ExportGuid;
        // END Zetbox.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("b88c12ac-eabe-4aee-913e-5edd9d2a193a");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.GUI.NavigationEntry)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Group)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.GUI.NavigationEntry; moduleNamespace=Zetbox.App.GUI;
        // will get inverse collection for notifications for Groups
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
		[System.Runtime.Serialization.IgnoreDataMember]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.App.GUI.NavigationEntry A
        {
            get { return AImpl; }
            set { AImpl = (Zetbox.App.GUI.NavigationEntryMemoryImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        private int? __fk_ACache;

        private int? _fk_A {
            get
            {
                return __fk_ACache;
            }
            set
            {
                __fk_ACache = value;
                // Recreate task to clear it's cache
                _triggerFetchATask = null;
            }
        }

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return _fk_A; }
			set { _fk_A = value; }
		}

        private Guid? _fk_guid_A = null;

        Zetbox.API.Async.ZbTask<Zetbox.App.GUI.NavigationEntry> _triggerFetchATask;
        public Zetbox.API.Async.ZbTask<Zetbox.App.GUI.NavigationEntry> TriggerFetchAAsync()
        {
            if (_triggerFetchATask != null) return _triggerFetchATask;

            if (_fk_A.HasValue)
                _triggerFetchATask = Context.FindAsync<Zetbox.App.GUI.NavigationEntry>(_fk_A.Value);
            else
                _triggerFetchATask = new Zetbox.API.Async.ZbTask<Zetbox.App.GUI.NavigationEntry>(Zetbox.API.Async.ZbTask.Synchron, () => null);

            return _triggerFetchATask;
        }

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Zetbox.App.GUI.NavigationEntryMemoryImpl AImpl
        {
            get
            {
                return (Zetbox.App.GUI.NavigationEntryMemoryImpl)TriggerFetchAAsync().Result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noops
                if ((value == null && _fk_A == null) || (value != null && value.ID == _fk_A))
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null)
                {
                    __oldValue.NotifyPropertyChanging("Groups", null, null);
                }

                if (__newValue != null)
                {
                    __newValue.NotifyPropertyChanging("Groups", null, null);
                }

                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                if (__oldValue != null)
                    __oldValue.OnGroupsCollectionChanged();

                if (__newValue != null)
                    __newValue.OnGroupsCollectionChanged();

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;
            }
        }
        // END Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Group; moduleNamespace=Zetbox.App.GUI;
        // no inverse navigator handling
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
		[System.Runtime.Serialization.IgnoreDataMember]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.App.Base.Group B
        {
            get { return BImpl; }
            set { BImpl = (Zetbox.App.Base.GroupMemoryImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        private int? __fk_BCache;

        private int? _fk_B {
            get
            {
                return __fk_BCache;
            }
            set
            {
                __fk_BCache = value;
                // Recreate task to clear it's cache
                _triggerFetchBTask = null;
            }
        }

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return _fk_B; }
			set { _fk_B = value; }
		}

        private Guid? _fk_guid_B = null;

        Zetbox.API.Async.ZbTask<Zetbox.App.Base.Group> _triggerFetchBTask;
        public Zetbox.API.Async.ZbTask<Zetbox.App.Base.Group> TriggerFetchBAsync()
        {
            if (_triggerFetchBTask != null) return _triggerFetchBTask;

            if (_fk_B.HasValue)
                _triggerFetchBTask = Context.FindAsync<Zetbox.App.Base.Group>(_fk_B.Value);
            else
                _triggerFetchBTask = new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Group>(Zetbox.API.Async.ZbTask.Synchron, () => null);

            return _triggerFetchBTask;
        }

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Zetbox.App.Base.GroupMemoryImpl BImpl
        {
            get
            {
                return (Zetbox.App.Base.GroupMemoryImpl)TriggerFetchBAsync().Result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noops
                if ((value == null && _fk_B == null) || (value != null && value.ID == _fk_B))
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;
            }
        }
        // END Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this._ExportGuid);
            binStream.Write(A != null ? A.ID : (int?)null);
            binStream.Write(B != null ? B.ID : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this._ExportGuid = binStream.ReadGuid();
            this._fk_A = binStream.ReadNullableInt32();
            this._fk_B = binStream.ReadNullableInt32();
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", _ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.GUI")) XmlStreamer.ToStream(A != null ? A.ExportGuid : (Guid?)null, xml, "A", "Zetbox.App.GUI");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.GUI")) XmlStreamer.ToStream(B != null ? B.ExportGuid : (Guid?)null, xml, "B", "Zetbox.App.GUI");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "|ExportGuid":
                this._ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "Zetbox.App.GUI|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.GUI|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(NavigationScreen_accessed_by_Groups_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (NavigationScreen_accessed_by_Groups_RelationEntryMemoryImpl)obj;
            var me = (NavigationScreen_accessed_by_Groups_RelationEntryMemoryImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                AImpl = (Zetbox.App.GUI.NavigationEntryMemoryImpl)Context.FindPersistenceObject<Zetbox.App.GUI.NavigationEntry>(_fk_guid_A.Value);
            else
            if (_fk_A.HasValue)
                AImpl = (Zetbox.App.GUI.NavigationEntryMemoryImpl)Context.Find<Zetbox.App.GUI.NavigationEntry>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_guid_B.HasValue)
                BImpl = (Zetbox.App.Base.GroupMemoryImpl)Context.FindPersistenceObject<Zetbox.App.Base.Group>(_fk_guid_B.Value);
            else
            if (_fk_B.HasValue)
                BImpl = (Zetbox.App.Base.GroupMemoryImpl)Context.Find<Zetbox.App.Base.Group>(_fk_B.Value);
            else
                BImpl = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }
    }
    // END Zetbox.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.GUI
{
    // BEGIN Zetbox.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("ObjRefProp_shows_Methods_RelationEntryMemoryImpl")]
    public class ObjRefProp_shows_Methods_RelationEntryMemoryImpl : Zetbox.DalProvider.Memory.RelationEntryMemoryImpl<Zetbox.App.Base.ObjectReferenceProperty, Zetbox.App.Base.ObjectReferencePropertyMemoryImpl, Zetbox.App.Base.Method, Zetbox.App.Base.MethodMemoryImpl>, ObjRefProp_shows_Methods_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        [Obsolete]
        public ObjRefProp_shows_Methods_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public ObjRefProp_shows_Methods_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Zetbox.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ID");
                }
            }
        }
        private int _ID;
        // END Zetbox.Generator.Templates.Properties.IdProperty
        // BEGIN Zetbox.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ExportGuid;
                if (_ExportGuid == Guid.Empty) {
                    __result = _ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ExportGuid != value)
                {
                    var __oldValue = _ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    _ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }
        private Guid _ExportGuid;
        // END Zetbox.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("02b3e9d5-fc2e-4ffe-8867-0977b88437cc");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Base.ObjectReferenceProperty)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Method)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Base.ObjectReferenceProperty; moduleNamespace=Zetbox.App.GUI;
        // will get inverse collection for notifications for Methods
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
		[System.Runtime.Serialization.IgnoreDataMember]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.App.Base.ObjectReferenceProperty A
        {
            get { return AImpl; }
            set { AImpl = (Zetbox.App.Base.ObjectReferencePropertyMemoryImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        private int? __fk_ACache;

        private int? _fk_A {
            get
            {
                return __fk_ACache;
            }
            set
            {
                __fk_ACache = value;
                // Recreate task to clear it's cache
                _triggerFetchATask = null;
            }
        }

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return _fk_A; }
			set { _fk_A = value; }
		}

        private Guid? _fk_guid_A = null;

        Zetbox.API.Async.ZbTask<Zetbox.App.Base.ObjectReferenceProperty> _triggerFetchATask;
        public Zetbox.API.Async.ZbTask<Zetbox.App.Base.ObjectReferenceProperty> TriggerFetchAAsync()
        {
            if (_triggerFetchATask != null) return _triggerFetchATask;

            if (_fk_A.HasValue)
                _triggerFetchATask = Context.FindAsync<Zetbox.App.Base.ObjectReferenceProperty>(_fk_A.Value);
            else
                _triggerFetchATask = new Zetbox.API.Async.ZbTask<Zetbox.App.Base.ObjectReferenceProperty>(Zetbox.API.Async.ZbTask.Synchron, () => null);

            return _triggerFetchATask;
        }

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Zetbox.App.Base.ObjectReferencePropertyMemoryImpl AImpl
        {
            get
            {
                return (Zetbox.App.Base.ObjectReferencePropertyMemoryImpl)TriggerFetchAAsync().Result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noops
                if ((value == null && _fk_A == null) || (value != null && value.ID == _fk_A))
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null)
                {
                    __oldValue.NotifyPropertyChanging("Methods", null, null);
                }

                if (__newValue != null)
                {
                    __newValue.NotifyPropertyChanging("Methods", null, null);
                }

                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                if (__oldValue != null)
                    __oldValue.OnMethodsCollectionChanged();

                if (__newValue != null)
                    __newValue.OnMethodsCollectionChanged();

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;
            }
        }
        // END Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Method; moduleNamespace=Zetbox.App.GUI;
        // will get inverse collection for notifications for ShowByProperties
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
		[System.Runtime.Serialization.IgnoreDataMember]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.App.Base.Method B
        {
            get { return BImpl; }
            set { BImpl = (Zetbox.App.Base.MethodMemoryImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        private int? __fk_BCache;

        private int? _fk_B {
            get
            {
                return __fk_BCache;
            }
            set
            {
                __fk_BCache = value;
                // Recreate task to clear it's cache
                _triggerFetchBTask = null;
            }
        }

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return _fk_B; }
			set { _fk_B = value; }
		}

        private Guid? _fk_guid_B = null;

        Zetbox.API.Async.ZbTask<Zetbox.App.Base.Method> _triggerFetchBTask;
        public Zetbox.API.Async.ZbTask<Zetbox.App.Base.Method> TriggerFetchBAsync()
        {
            if (_triggerFetchBTask != null) return _triggerFetchBTask;

            if (_fk_B.HasValue)
                _triggerFetchBTask = Context.FindAsync<Zetbox.App.Base.Method>(_fk_B.Value);
            else
                _triggerFetchBTask = new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Method>(Zetbox.API.Async.ZbTask.Synchron, () => null);

            return _triggerFetchBTask;
        }

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Zetbox.App.Base.MethodMemoryImpl BImpl
        {
            get
            {
                return (Zetbox.App.Base.MethodMemoryImpl)TriggerFetchBAsync().Result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noops
                if ((value == null && _fk_B == null) || (value != null && value.ID == _fk_B))
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                if (__oldValue != null)
                {
                    __oldValue.NotifyPropertyChanging("ShowByProperties", null, null);
                }

                if (__newValue != null)
                {
                    __newValue.NotifyPropertyChanging("ShowByProperties", null, null);
                }

                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                if (__oldValue != null)
                    __oldValue.OnShowByPropertiesCollectionChanged();

                if (__newValue != null)
                    __newValue.OnShowByPropertiesCollectionChanged();

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;
            }
        }
        // END Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this._ExportGuid);
            binStream.Write(A != null ? A.ID : (int?)null);
            binStream.Write(B != null ? B.ID : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this._ExportGuid = binStream.ReadGuid();
            this._fk_A = binStream.ReadNullableInt32();
            this._fk_B = binStream.ReadNullableInt32();
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", _ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.GUI")) XmlStreamer.ToStream(A != null ? A.ExportGuid : (Guid?)null, xml, "A", "Zetbox.App.GUI");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.GUI")) XmlStreamer.ToStream(B != null ? B.ExportGuid : (Guid?)null, xml, "B", "Zetbox.App.GUI");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "|ExportGuid":
                this._ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "Zetbox.App.GUI|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.GUI|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(ObjRefProp_shows_Methods_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (ObjRefProp_shows_Methods_RelationEntryMemoryImpl)obj;
            var me = (ObjRefProp_shows_Methods_RelationEntryMemoryImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                AImpl = (Zetbox.App.Base.ObjectReferencePropertyMemoryImpl)Context.FindPersistenceObject<Zetbox.App.Base.ObjectReferenceProperty>(_fk_guid_A.Value);
            else
            if (_fk_A.HasValue)
                AImpl = (Zetbox.App.Base.ObjectReferencePropertyMemoryImpl)Context.Find<Zetbox.App.Base.ObjectReferenceProperty>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_guid_B.HasValue)
                BImpl = (Zetbox.App.Base.MethodMemoryImpl)Context.FindPersistenceObject<Zetbox.App.Base.Method>(_fk_guid_B.Value);
            else
            if (_fk_B.HasValue)
                BImpl = (Zetbox.App.Base.MethodMemoryImpl)Context.Find<Zetbox.App.Base.Method>(_fk_B.Value);
            else
                BImpl = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }
    }
    // END Zetbox.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.GUI
{
    // BEGIN Zetbox.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("Presentable_displayedBy_SecondaryControlKinds_RelationEntryMemoryImpl")]
    public class Presentable_displayedBy_SecondaryControlKinds_RelationEntryMemoryImpl : Zetbox.DalProvider.Memory.RelationEntryMemoryImpl<Zetbox.App.GUI.ViewModelDescriptor, Zetbox.App.GUI.ViewModelDescriptorMemoryImpl, Zetbox.App.GUI.ControlKind, Zetbox.App.GUI.ControlKindMemoryImpl>, Presentable_displayedBy_SecondaryControlKinds_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        [Obsolete]
        public Presentable_displayedBy_SecondaryControlKinds_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public Presentable_displayedBy_SecondaryControlKinds_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Zetbox.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ID");
                }
            }
        }
        private int _ID;
        // END Zetbox.Generator.Templates.Properties.IdProperty
        // BEGIN Zetbox.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ExportGuid;
                if (_ExportGuid == Guid.Empty) {
                    __result = _ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ExportGuid != value)
                {
                    var __oldValue = _ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    _ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }
        private Guid _ExportGuid;
        // END Zetbox.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("5404456a-4527-4e40-a660-b4a5e96e4a47");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.GUI.ViewModelDescriptor)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.GUI.ControlKind)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.GUI.ViewModelDescriptor; moduleNamespace=Zetbox.App.GUI;
        // will get inverse collection for notifications for SecondaryControlKinds
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
		[System.Runtime.Serialization.IgnoreDataMember]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.App.GUI.ViewModelDescriptor A
        {
            get { return AImpl; }
            set { AImpl = (Zetbox.App.GUI.ViewModelDescriptorMemoryImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        private int? __fk_ACache;

        private int? _fk_A {
            get
            {
                return __fk_ACache;
            }
            set
            {
                __fk_ACache = value;
                // Recreate task to clear it's cache
                _triggerFetchATask = null;
            }
        }

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return _fk_A; }
			set { _fk_A = value; }
		}

        private Guid? _fk_guid_A = null;

        Zetbox.API.Async.ZbTask<Zetbox.App.GUI.ViewModelDescriptor> _triggerFetchATask;
        public Zetbox.API.Async.ZbTask<Zetbox.App.GUI.ViewModelDescriptor> TriggerFetchAAsync()
        {
            if (_triggerFetchATask != null) return _triggerFetchATask;

            if (_fk_A.HasValue)
                _triggerFetchATask = Context.FindAsync<Zetbox.App.GUI.ViewModelDescriptor>(_fk_A.Value);
            else
                _triggerFetchATask = new Zetbox.API.Async.ZbTask<Zetbox.App.GUI.ViewModelDescriptor>(Zetbox.API.Async.ZbTask.Synchron, () => null);

            return _triggerFetchATask;
        }

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Zetbox.App.GUI.ViewModelDescriptorMemoryImpl AImpl
        {
            get
            {
                return (Zetbox.App.GUI.ViewModelDescriptorMemoryImpl)TriggerFetchAAsync().Result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noops
                if ((value == null && _fk_A == null) || (value != null && value.ID == _fk_A))
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null)
                {
                    __oldValue.NotifyPropertyChanging("SecondaryControlKinds", null, null);
                }

                if (__newValue != null)
                {
                    __newValue.NotifyPropertyChanging("SecondaryControlKinds", null, null);
                }

                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                if (__oldValue != null)
                    __oldValue.OnSecondaryControlKindsCollectionChanged();

                if (__newValue != null)
                    __newValue.OnSecondaryControlKindsCollectionChanged();

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;
            }
        }
        // END Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.GUI.ControlKind; moduleNamespace=Zetbox.App.GUI;
        // no inverse navigator handling
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
		[System.Runtime.Serialization.IgnoreDataMember]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.App.GUI.ControlKind B
        {
            get { return BImpl; }
            set { BImpl = (Zetbox.App.GUI.ControlKindMemoryImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        private int? __fk_BCache;

        private int? _fk_B {
            get
            {
                return __fk_BCache;
            }
            set
            {
                __fk_BCache = value;
                // Recreate task to clear it's cache
                _triggerFetchBTask = null;
            }
        }

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return _fk_B; }
			set { _fk_B = value; }
		}

        private Guid? _fk_guid_B = null;

        Zetbox.API.Async.ZbTask<Zetbox.App.GUI.ControlKind> _triggerFetchBTask;
        public Zetbox.API.Async.ZbTask<Zetbox.App.GUI.ControlKind> TriggerFetchBAsync()
        {
            if (_triggerFetchBTask != null) return _triggerFetchBTask;

            if (_fk_B.HasValue)
                _triggerFetchBTask = Context.FindAsync<Zetbox.App.GUI.ControlKind>(_fk_B.Value);
            else
                _triggerFetchBTask = new Zetbox.API.Async.ZbTask<Zetbox.App.GUI.ControlKind>(Zetbox.API.Async.ZbTask.Synchron, () => null);

            return _triggerFetchBTask;
        }

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Zetbox.App.GUI.ControlKindMemoryImpl BImpl
        {
            get
            {
                return (Zetbox.App.GUI.ControlKindMemoryImpl)TriggerFetchBAsync().Result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noops
                if ((value == null && _fk_B == null) || (value != null && value.ID == _fk_B))
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;
            }
        }
        // END Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this._ExportGuid);
            binStream.Write(A != null ? A.ID : (int?)null);
            binStream.Write(B != null ? B.ID : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this._ExportGuid = binStream.ReadGuid();
            this._fk_A = binStream.ReadNullableInt32();
            this._fk_B = binStream.ReadNullableInt32();
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", _ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.GUI")) XmlStreamer.ToStream(A != null ? A.ExportGuid : (Guid?)null, xml, "A", "Zetbox.App.GUI");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.GUI")) XmlStreamer.ToStream(B != null ? B.ExportGuid : (Guid?)null, xml, "B", "Zetbox.App.GUI");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "|ExportGuid":
                this._ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "Zetbox.App.GUI|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.GUI|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Presentable_displayedBy_SecondaryControlKinds_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Presentable_displayedBy_SecondaryControlKinds_RelationEntryMemoryImpl)obj;
            var me = (Presentable_displayedBy_SecondaryControlKinds_RelationEntryMemoryImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                AImpl = (Zetbox.App.GUI.ViewModelDescriptorMemoryImpl)Context.FindPersistenceObject<Zetbox.App.GUI.ViewModelDescriptor>(_fk_guid_A.Value);
            else
            if (_fk_A.HasValue)
                AImpl = (Zetbox.App.GUI.ViewModelDescriptorMemoryImpl)Context.Find<Zetbox.App.GUI.ViewModelDescriptor>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_guid_B.HasValue)
                BImpl = (Zetbox.App.GUI.ControlKindMemoryImpl)Context.FindPersistenceObject<Zetbox.App.GUI.ControlKind>(_fk_guid_B.Value);
            else
            if (_fk_B.HasValue)
                BImpl = (Zetbox.App.GUI.ControlKindMemoryImpl)Context.Find<Zetbox.App.GUI.ControlKind>(_fk_B.Value);
            else
                BImpl = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }
    }
    // END Zetbox.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.Base
{
    // BEGIN Zetbox.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("RoleMembership_resolves_Relations_RelationEntryMemoryImpl")]
    public class RoleMembership_resolves_Relations_RelationEntryMemoryImpl : Zetbox.DalProvider.Memory.RelationEntryMemoryImpl<Zetbox.App.Base.RoleMembership, Zetbox.App.Base.RoleMembershipMemoryImpl, Zetbox.App.Base.Relation, Zetbox.App.Base.RelationMemoryImpl>, RoleMembership_resolves_Relations_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        [Obsolete]
        public RoleMembership_resolves_Relations_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public RoleMembership_resolves_Relations_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Zetbox.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ID");
                }
            }
        }
        private int _ID;
        // END Zetbox.Generator.Templates.Properties.IdProperty
        // BEGIN Zetbox.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ExportGuid;
                if (_ExportGuid == Guid.Empty) {
                    __result = _ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ExportGuid != value)
                {
                    var __oldValue = _ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    _ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }
        private Guid _ExportGuid;
        // END Zetbox.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("f74d425f-e733-4cba-baca-f4a05fbc0a80");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Base.RoleMembership)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Relation)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Base.RoleMembership; moduleNamespace=Zetbox.App.Base;
        // will get inverse collection for notifications for Relations
        // PositionStorage=A_pos;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
		[System.Runtime.Serialization.IgnoreDataMember]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.App.Base.RoleMembership A
        {
            get { return AImpl; }
            set { AImpl = (Zetbox.App.Base.RoleMembershipMemoryImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        private int? __fk_ACache;

        private int? _fk_A {
            get
            {
                return __fk_ACache;
            }
            set
            {
                __fk_ACache = value;
                // Recreate task to clear it's cache
                _triggerFetchATask = null;
            }
        }

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return _fk_A; }
			set { _fk_A = value; }
		}

        private Guid? _fk_guid_A = null;

        Zetbox.API.Async.ZbTask<Zetbox.App.Base.RoleMembership> _triggerFetchATask;
        public Zetbox.API.Async.ZbTask<Zetbox.App.Base.RoleMembership> TriggerFetchAAsync()
        {
            if (_triggerFetchATask != null) return _triggerFetchATask;

            if (_fk_A.HasValue)
                _triggerFetchATask = Context.FindAsync<Zetbox.App.Base.RoleMembership>(_fk_A.Value);
            else
                _triggerFetchATask = new Zetbox.API.Async.ZbTask<Zetbox.App.Base.RoleMembership>(Zetbox.API.Async.ZbTask.Synchron, () => null);

            return _triggerFetchATask;
        }

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Zetbox.App.Base.RoleMembershipMemoryImpl AImpl
        {
            get
            {
                return (Zetbox.App.Base.RoleMembershipMemoryImpl)TriggerFetchAAsync().Result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noops
                if ((value == null && _fk_A == null) || (value != null && value.ID == _fk_A))
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null)
                {
                    __oldValue.NotifyPropertyChanging("Relations", null, null);
                }

                if (__newValue != null)
                {
                    __newValue.NotifyPropertyChanging("Relations", null, null);
                }

                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                if (__oldValue != null)
                    __oldValue.OnRelationsCollectionChanged();

                if (__newValue != null)
                    __newValue.OnRelationsCollectionChanged();

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;
            }
        }
        // BEGIN Zetbox.Generator.Templates.Properties.NotifyingValueProperty
        public int? A_pos
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _A_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_A_pos != value)
                {
                    var __oldValue = _A_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("A_pos", __oldValue, __newValue);
                    _A_pos = __newValue;
                    NotifyPropertyChanged("A_pos", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("A_pos");
                }
            }
        }
        private int? _A_pos;
        // END Zetbox.Generator.Templates.Properties.NotifyingValueProperty
        // END Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Relation; moduleNamespace=Zetbox.App.Base;
        // no inverse navigator handling
        // PositionStorage=B_pos;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
		[System.Runtime.Serialization.IgnoreDataMember]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.App.Base.Relation B
        {
            get { return BImpl; }
            set { BImpl = (Zetbox.App.Base.RelationMemoryImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        private int? __fk_BCache;

        private int? _fk_B {
            get
            {
                return __fk_BCache;
            }
            set
            {
                __fk_BCache = value;
                // Recreate task to clear it's cache
                _triggerFetchBTask = null;
            }
        }

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return _fk_B; }
			set { _fk_B = value; }
		}

        private Guid? _fk_guid_B = null;

        Zetbox.API.Async.ZbTask<Zetbox.App.Base.Relation> _triggerFetchBTask;
        public Zetbox.API.Async.ZbTask<Zetbox.App.Base.Relation> TriggerFetchBAsync()
        {
            if (_triggerFetchBTask != null) return _triggerFetchBTask;

            if (_fk_B.HasValue)
                _triggerFetchBTask = Context.FindAsync<Zetbox.App.Base.Relation>(_fk_B.Value);
            else
                _triggerFetchBTask = new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Relation>(Zetbox.API.Async.ZbTask.Synchron, () => null);

            return _triggerFetchBTask;
        }

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Zetbox.App.Base.RelationMemoryImpl BImpl
        {
            get
            {
                return (Zetbox.App.Base.RelationMemoryImpl)TriggerFetchBAsync().Result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noops
                if ((value == null && _fk_B == null) || (value != null && value.ID == _fk_B))
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;
            }
        }
        // BEGIN Zetbox.Generator.Templates.Properties.NotifyingValueProperty
        public int? B_pos
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _B_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_B_pos != value)
                {
                    var __oldValue = _B_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("B_pos", __oldValue, __newValue);
                    _B_pos = __newValue;
                    NotifyPropertyChanged("B_pos", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("B_pos");
                }
            }
        }
        private int? _B_pos;
        // END Zetbox.Generator.Templates.Properties.NotifyingValueProperty
        // END Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        /// <summary>
        /// Index into the A-side list of this relation
        /// </summary>
        public int? AIndex { get { return _A_pos; } set { _A_pos = value; } }

        /// <summary>
        /// Index into the B-side list of this relation
        /// </summary>
        public int? BIndex { get { return _B_pos; } set { _B_pos = value; } }

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this._ExportGuid);
            binStream.Write(A != null ? A.ID : (int?)null);
            binStream.Write(this._A_pos);
            binStream.Write(B != null ? B.ID : (int?)null);
            binStream.Write(this._B_pos);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this._ExportGuid = binStream.ReadGuid();
            this._fk_A = binStream.ReadNullableInt32();
            this._A_pos = binStream.ReadNullableInt32();
            this._fk_B = binStream.ReadNullableInt32();
            this._B_pos = binStream.ReadNullableInt32();
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", _ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(A != null ? A.ExportGuid : (Guid?)null, xml, "A", "Zetbox.App.Base");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(this._A_pos, xml, "A_pos", "Zetbox.App.Base");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(B != null ? B.ExportGuid : (Guid?)null, xml, "B", "Zetbox.App.Base");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(this._B_pos, xml, "B_pos", "Zetbox.App.Base");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "|ExportGuid":
                this._ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "Zetbox.App.Base|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.Base|A_pos":
                this._A_pos = XmlStreamer.ReadNullableInt32(xml);
                break;
            case "Zetbox.App.Base|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.Base|B_pos":
                this._B_pos = XmlStreamer.ReadNullableInt32(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(RoleMembership_resolves_Relations_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (RoleMembership_resolves_Relations_RelationEntryMemoryImpl)obj;
            var me = (RoleMembership_resolves_Relations_RelationEntryMemoryImpl)this;

            me._fk_A = other._fk_A;
            me.AIndex = other.AIndex;
            me._fk_B = other._fk_B;
            me.BIndex = other.BIndex;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                AImpl = (Zetbox.App.Base.RoleMembershipMemoryImpl)Context.FindPersistenceObject<Zetbox.App.Base.RoleMembership>(_fk_guid_A.Value);
            else
            if (_fk_A.HasValue)
                AImpl = (Zetbox.App.Base.RoleMembershipMemoryImpl)Context.Find<Zetbox.App.Base.RoleMembership>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_guid_B.HasValue)
                BImpl = (Zetbox.App.Base.RelationMemoryImpl)Context.FindPersistenceObject<Zetbox.App.Base.Relation>(_fk_guid_B.Value);
            else
            if (_fk_B.HasValue)
                BImpl = (Zetbox.App.Base.RelationMemoryImpl)Context.Find<Zetbox.App.Base.Relation>(_fk_B.Value);
            else
                BImpl = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }
    }
    // END Zetbox.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.SchemaMigration
{
    // BEGIN Zetbox.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("SourceColumn_created_Property_RelationEntryMemoryImpl")]
    public class SourceColumn_created_Property_RelationEntryMemoryImpl : Zetbox.DalProvider.Memory.RelationEntryMemoryImpl<Zetbox.App.SchemaMigration.SourceColumn, Zetbox.App.SchemaMigration.SourceColumnMemoryImpl, Zetbox.App.Base.Property, Zetbox.App.Base.PropertyMemoryImpl>, SourceColumn_created_Property_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        [Obsolete]
        public SourceColumn_created_Property_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public SourceColumn_created_Property_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Zetbox.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ID");
                }
            }
        }
        private int _ID;
        // END Zetbox.Generator.Templates.Properties.IdProperty
        // BEGIN Zetbox.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ExportGuid;
                if (_ExportGuid == Guid.Empty) {
                    __result = _ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ExportGuid != value)
                {
                    var __oldValue = _ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    _ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }
        private Guid _ExportGuid;
        // END Zetbox.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("fb27e3f8-3615-4f3b-ae2a-2b89b8782e27");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.SchemaMigration.SourceColumn)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Property)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.SchemaMigration.SourceColumn; moduleNamespace=Zetbox.App.SchemaMigration;
        // will get inverse collection for notifications for DestinationProperty
        // PositionStorage=A_pos;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
		[System.Runtime.Serialization.IgnoreDataMember]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.App.SchemaMigration.SourceColumn A
        {
            get { return AImpl; }
            set { AImpl = (Zetbox.App.SchemaMigration.SourceColumnMemoryImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        private int? __fk_ACache;

        private int? _fk_A {
            get
            {
                return __fk_ACache;
            }
            set
            {
                __fk_ACache = value;
                // Recreate task to clear it's cache
                _triggerFetchATask = null;
            }
        }

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return _fk_A; }
			set { _fk_A = value; }
		}

        private Guid? _fk_guid_A = null;

        Zetbox.API.Async.ZbTask<Zetbox.App.SchemaMigration.SourceColumn> _triggerFetchATask;
        public Zetbox.API.Async.ZbTask<Zetbox.App.SchemaMigration.SourceColumn> TriggerFetchAAsync()
        {
            if (_triggerFetchATask != null) return _triggerFetchATask;

            if (_fk_A.HasValue)
                _triggerFetchATask = Context.FindAsync<Zetbox.App.SchemaMigration.SourceColumn>(_fk_A.Value);
            else
                _triggerFetchATask = new Zetbox.API.Async.ZbTask<Zetbox.App.SchemaMigration.SourceColumn>(Zetbox.API.Async.ZbTask.Synchron, () => null);

            return _triggerFetchATask;
        }

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Zetbox.App.SchemaMigration.SourceColumnMemoryImpl AImpl
        {
            get
            {
                return (Zetbox.App.SchemaMigration.SourceColumnMemoryImpl)TriggerFetchAAsync().Result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noops
                if ((value == null && _fk_A == null) || (value != null && value.ID == _fk_A))
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null)
                {
                    __oldValue.NotifyPropertyChanging("DestinationProperty", null, null);
                }

                if (__newValue != null)
                {
                    __newValue.NotifyPropertyChanging("DestinationProperty", null, null);
                }

                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                if (__oldValue != null)
                    __oldValue.OnDestinationPropertyCollectionChanged();

                if (__newValue != null)
                    __newValue.OnDestinationPropertyCollectionChanged();

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;
            }
        }
        // BEGIN Zetbox.Generator.Templates.Properties.NotifyingValueProperty
        public int? A_pos
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _A_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_A_pos != value)
                {
                    var __oldValue = _A_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("A_pos", __oldValue, __newValue);
                    _A_pos = __newValue;
                    NotifyPropertyChanged("A_pos", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("A_pos");
                }
            }
        }
        private int? _A_pos;
        // END Zetbox.Generator.Templates.Properties.NotifyingValueProperty
        // END Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Property; moduleNamespace=Zetbox.App.SchemaMigration;
        // no inverse navigator handling
        // PositionStorage=B_pos;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
		[System.Runtime.Serialization.IgnoreDataMember]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.App.Base.Property B
        {
            get { return BImpl; }
            set { BImpl = (Zetbox.App.Base.PropertyMemoryImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        private int? __fk_BCache;

        private int? _fk_B {
            get
            {
                return __fk_BCache;
            }
            set
            {
                __fk_BCache = value;
                // Recreate task to clear it's cache
                _triggerFetchBTask = null;
            }
        }

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return _fk_B; }
			set { _fk_B = value; }
		}

        private Guid? _fk_guid_B = null;

        Zetbox.API.Async.ZbTask<Zetbox.App.Base.Property> _triggerFetchBTask;
        public Zetbox.API.Async.ZbTask<Zetbox.App.Base.Property> TriggerFetchBAsync()
        {
            if (_triggerFetchBTask != null) return _triggerFetchBTask;

            if (_fk_B.HasValue)
                _triggerFetchBTask = Context.FindAsync<Zetbox.App.Base.Property>(_fk_B.Value);
            else
                _triggerFetchBTask = new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Property>(Zetbox.API.Async.ZbTask.Synchron, () => null);

            return _triggerFetchBTask;
        }

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Zetbox.App.Base.PropertyMemoryImpl BImpl
        {
            get
            {
                return (Zetbox.App.Base.PropertyMemoryImpl)TriggerFetchBAsync().Result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noops
                if ((value == null && _fk_B == null) || (value != null && value.ID == _fk_B))
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;
            }
        }
        // BEGIN Zetbox.Generator.Templates.Properties.NotifyingValueProperty
        public int? B_pos
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _B_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_B_pos != value)
                {
                    var __oldValue = _B_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("B_pos", __oldValue, __newValue);
                    _B_pos = __newValue;
                    NotifyPropertyChanged("B_pos", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("B_pos");
                }
            }
        }
        private int? _B_pos;
        // END Zetbox.Generator.Templates.Properties.NotifyingValueProperty
        // END Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        /// <summary>
        /// Index into the A-side list of this relation
        /// </summary>
        public int? AIndex { get { return _A_pos; } set { _A_pos = value; } }

        /// <summary>
        /// Index into the B-side list of this relation
        /// </summary>
        public int? BIndex { get { return _B_pos; } set { _B_pos = value; } }

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this._ExportGuid);
            binStream.Write(A != null ? A.ID : (int?)null);
            binStream.Write(this._A_pos);
            binStream.Write(B != null ? B.ID : (int?)null);
            binStream.Write(this._B_pos);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this._ExportGuid = binStream.ReadGuid();
            this._fk_A = binStream.ReadNullableInt32();
            this._A_pos = binStream.ReadNullableInt32();
            this._fk_B = binStream.ReadNullableInt32();
            this._B_pos = binStream.ReadNullableInt32();
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", _ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.SchemaMigration")) XmlStreamer.ToStream(A != null ? A.ExportGuid : (Guid?)null, xml, "A", "Zetbox.App.SchemaMigration");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.SchemaMigration")) XmlStreamer.ToStream(this._A_pos, xml, "A_pos", "Zetbox.App.SchemaMigration");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.SchemaMigration")) XmlStreamer.ToStream(B != null ? B.ExportGuid : (Guid?)null, xml, "B", "Zetbox.App.SchemaMigration");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.SchemaMigration")) XmlStreamer.ToStream(this._B_pos, xml, "B_pos", "Zetbox.App.SchemaMigration");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "|ExportGuid":
                this._ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "Zetbox.App.SchemaMigration|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.SchemaMigration|A_pos":
                this._A_pos = XmlStreamer.ReadNullableInt32(xml);
                break;
            case "Zetbox.App.SchemaMigration|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.SchemaMigration|B_pos":
                this._B_pos = XmlStreamer.ReadNullableInt32(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(SourceColumn_created_Property_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (SourceColumn_created_Property_RelationEntryMemoryImpl)obj;
            var me = (SourceColumn_created_Property_RelationEntryMemoryImpl)this;

            me._fk_A = other._fk_A;
            me.AIndex = other.AIndex;
            me._fk_B = other._fk_B;
            me.BIndex = other.BIndex;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                AImpl = (Zetbox.App.SchemaMigration.SourceColumnMemoryImpl)Context.FindPersistenceObject<Zetbox.App.SchemaMigration.SourceColumn>(_fk_guid_A.Value);
            else
            if (_fk_A.HasValue)
                AImpl = (Zetbox.App.SchemaMigration.SourceColumnMemoryImpl)Context.Find<Zetbox.App.SchemaMigration.SourceColumn>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_guid_B.HasValue)
                BImpl = (Zetbox.App.Base.PropertyMemoryImpl)Context.FindPersistenceObject<Zetbox.App.Base.Property>(_fk_guid_B.Value);
            else
            if (_fk_B.HasValue)
                BImpl = (Zetbox.App.Base.PropertyMemoryImpl)Context.Find<Zetbox.App.Base.Property>(_fk_B.Value);
            else
                BImpl = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }
    }
    // END Zetbox.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.Base
{
    // BEGIN Zetbox.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("UniqueContraints_ensures_unique_on_Properties_RelationEntryMemoryImpl")]
    public class UniqueContraints_ensures_unique_on_Properties_RelationEntryMemoryImpl : Zetbox.DalProvider.Memory.RelationEntryMemoryImpl<Zetbox.App.Base.IndexConstraint, Zetbox.App.Base.IndexConstraintMemoryImpl, Zetbox.App.Base.Property, Zetbox.App.Base.PropertyMemoryImpl>, UniqueContraints_ensures_unique_on_Properties_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        [Obsolete]
        public UniqueContraints_ensures_unique_on_Properties_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public UniqueContraints_ensures_unique_on_Properties_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Zetbox.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ID");
                }
            }
        }
        private int _ID;
        // END Zetbox.Generator.Templates.Properties.IdProperty
        // BEGIN Zetbox.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ExportGuid;
                if (_ExportGuid == Guid.Empty) {
                    __result = _ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ExportGuid != value)
                {
                    var __oldValue = _ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    _ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }
        private Guid _ExportGuid;
        // END Zetbox.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("29235ba6-5979-4ed8-8e75-6bd0837c7f28");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Base.IndexConstraint)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Property)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Base.IndexConstraint; moduleNamespace=Zetbox.App.Base;
        // will get inverse collection for notifications for Properties
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
		[System.Runtime.Serialization.IgnoreDataMember]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.App.Base.IndexConstraint A
        {
            get { return AImpl; }
            set { AImpl = (Zetbox.App.Base.IndexConstraintMemoryImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        private int? __fk_ACache;

        private int? _fk_A {
            get
            {
                return __fk_ACache;
            }
            set
            {
                __fk_ACache = value;
                // Recreate task to clear it's cache
                _triggerFetchATask = null;
            }
        }

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return _fk_A; }
			set { _fk_A = value; }
		}

        private Guid? _fk_guid_A = null;

        Zetbox.API.Async.ZbTask<Zetbox.App.Base.IndexConstraint> _triggerFetchATask;
        public Zetbox.API.Async.ZbTask<Zetbox.App.Base.IndexConstraint> TriggerFetchAAsync()
        {
            if (_triggerFetchATask != null) return _triggerFetchATask;

            if (_fk_A.HasValue)
                _triggerFetchATask = Context.FindAsync<Zetbox.App.Base.IndexConstraint>(_fk_A.Value);
            else
                _triggerFetchATask = new Zetbox.API.Async.ZbTask<Zetbox.App.Base.IndexConstraint>(Zetbox.API.Async.ZbTask.Synchron, () => null);

            return _triggerFetchATask;
        }

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Zetbox.App.Base.IndexConstraintMemoryImpl AImpl
        {
            get
            {
                return (Zetbox.App.Base.IndexConstraintMemoryImpl)TriggerFetchAAsync().Result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noops
                if ((value == null && _fk_A == null) || (value != null && value.ID == _fk_A))
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null)
                {
                    __oldValue.NotifyPropertyChanging("Properties", null, null);
                }

                if (__newValue != null)
                {
                    __newValue.NotifyPropertyChanging("Properties", null, null);
                }

                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                if (__oldValue != null)
                    __oldValue.OnPropertiesCollectionChanged();

                if (__newValue != null)
                    __newValue.OnPropertiesCollectionChanged();

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;
            }
        }
        // END Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Property; moduleNamespace=Zetbox.App.Base;
        // no inverse navigator handling
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
		[System.Runtime.Serialization.IgnoreDataMember]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.App.Base.Property B
        {
            get { return BImpl; }
            set { BImpl = (Zetbox.App.Base.PropertyMemoryImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        private int? __fk_BCache;

        private int? _fk_B {
            get
            {
                return __fk_BCache;
            }
            set
            {
                __fk_BCache = value;
                // Recreate task to clear it's cache
                _triggerFetchBTask = null;
            }
        }

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return _fk_B; }
			set { _fk_B = value; }
		}

        private Guid? _fk_guid_B = null;

        Zetbox.API.Async.ZbTask<Zetbox.App.Base.Property> _triggerFetchBTask;
        public Zetbox.API.Async.ZbTask<Zetbox.App.Base.Property> TriggerFetchBAsync()
        {
            if (_triggerFetchBTask != null) return _triggerFetchBTask;

            if (_fk_B.HasValue)
                _triggerFetchBTask = Context.FindAsync<Zetbox.App.Base.Property>(_fk_B.Value);
            else
                _triggerFetchBTask = new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Property>(Zetbox.API.Async.ZbTask.Synchron, () => null);

            return _triggerFetchBTask;
        }

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Zetbox.App.Base.PropertyMemoryImpl BImpl
        {
            get
            {
                return (Zetbox.App.Base.PropertyMemoryImpl)TriggerFetchBAsync().Result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noops
                if ((value == null && _fk_B == null) || (value != null && value.ID == _fk_B))
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;
            }
        }
        // END Zetbox.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this._ExportGuid);
            binStream.Write(A != null ? A.ID : (int?)null);
            binStream.Write(B != null ? B.ID : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this._ExportGuid = binStream.ReadGuid();
            this._fk_A = binStream.ReadNullableInt32();
            this._fk_B = binStream.ReadNullableInt32();
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", _ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(A != null ? A.ExportGuid : (Guid?)null, xml, "A", "Zetbox.App.Base");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(B != null ? B.ExportGuid : (Guid?)null, xml, "B", "Zetbox.App.Base");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "|ExportGuid":
                this._ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "Zetbox.App.Base|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.Base|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(UniqueContraints_ensures_unique_on_Properties_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (UniqueContraints_ensures_unique_on_Properties_RelationEntryMemoryImpl)obj;
            var me = (UniqueContraints_ensures_unique_on_Properties_RelationEntryMemoryImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                AImpl = (Zetbox.App.Base.IndexConstraintMemoryImpl)Context.FindPersistenceObject<Zetbox.App.Base.IndexConstraint>(_fk_guid_A.Value);
            else
            if (_fk_A.HasValue)
                AImpl = (Zetbox.App.Base.IndexConstraintMemoryImpl)Context.Find<Zetbox.App.Base.IndexConstraint>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_guid_B.HasValue)
                BImpl = (Zetbox.App.Base.PropertyMemoryImpl)Context.FindPersistenceObject<Zetbox.App.Base.Property>(_fk_guid_B.Value);
            else
            if (_fk_B.HasValue)
                BImpl = (Zetbox.App.Base.PropertyMemoryImpl)Context.Find<Zetbox.App.Base.Property>(_fk_B.Value);
            else
                BImpl = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }
    }
    // END Zetbox.Generator.Templates.CollectionEntries.RelationEntry
}
