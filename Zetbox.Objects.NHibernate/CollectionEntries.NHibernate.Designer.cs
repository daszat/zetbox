// <autogenerated/>

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Xml;
using System.Xml.Serialization;
using System.Linq;

using Zetbox.API;
using Zetbox.DalProvider.Base.RelationWrappers;
using Zetbox.API.Utils;
using Zetbox.DalProvider.Base;
using Zetbox.DalProvider.NHibernate;

namespace Zetbox.App.Test
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("ASide_connectsTo_BSide_RelationEntryNHibernateImpl")]
    public class ASide_connectsTo_BSide_RelationEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.RelationEntryNHibernateImpl<Zetbox.App.Test.N_to_M_relations_A, Zetbox.App.Test.N_to_M_relations_ANHibernateImpl, Zetbox.App.Test.N_to_M_relations_B, Zetbox.App.Test.N_to_M_relations_BNHibernateImpl>, ASide_connectsTo_BSide_RelationEntry
    {
        public ASide_connectsTo_BSide_RelationEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public ASide_connectsTo_BSide_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new ASide_connectsTo_BSide_RelationEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public ASide_connectsTo_BSide_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, ASide_connectsTo_BSide_RelationEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly ASide_connectsTo_BSide_RelationEntryProxy Proxy;
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("3555da6e-0e9b-4f7c-903e-a51f3cce7cd9");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Test.N_to_M_relations_A)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Test.N_to_M_relations_B)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=this.Proxy.A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Test.N_to_M_relations_A; moduleNamespace=Zetbox.App.Test;
        // will get inverse collection for notifications for BSide
        // PositionStorage=none;
        // Target not exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Test.N_to_M_relations_A A
        {
            get
            {
                Zetbox.App.Test.N_to_M_relations_ANHibernateImpl __value = (Zetbox.App.Test.N_to_M_relations_ANHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.A == null)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Test.N_to_M_relations_ANHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);
                var __newValue = (Zetbox.App.Test.N_to_M_relations_ANHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("BSide", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("BSide", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.A = null;
                }
                else
                {
                    this.Proxy.A = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.BSide as IRelationListSync<Zetbox.App.Test.ASide_connectsTo_BSide_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.BSide as IRelationListSync<Zetbox.App.Test.ASide_connectsTo_BSide_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for A's id, used on dehydration only</summary>
        private int? _fk_A = null;

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return A != null ? A.ID : (int?)null; }
			set { _fk_A = value; }
		}


    public Zetbox.API.Async.ZbTask TriggerFetchAAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Test.N_to_M_relations_A>(this.A);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=this.Proxy.B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Test.N_to_M_relations_B; moduleNamespace=Zetbox.App.Test;
        // will get inverse collection for notifications for ASide
        // PositionStorage=none;
        // Target not exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Test.N_to_M_relations_B B
        {
            get
            {
                Zetbox.App.Test.N_to_M_relations_BNHibernateImpl __value = (Zetbox.App.Test.N_to_M_relations_BNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.B == null)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Test.N_to_M_relations_BNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);
                var __newValue = (Zetbox.App.Test.N_to_M_relations_BNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("ASide", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("ASide", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.B = null;
                }
                else
                {
                    this.Proxy.B = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.ASide as IRelationListSync<Zetbox.App.Test.ASide_connectsTo_BSide_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.ASide as IRelationListSync<Zetbox.App.Test.ASide_connectsTo_BSide_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for B's id, used on dehydration only</summary>
        private int? _fk_B = null;

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return B != null ? B.ID : (int?)null; }
			set { _fk_B = value; }
		}


    public Zetbox.API.Async.ZbTask TriggerFetchBAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Test.N_to_M_relations_B>(this.B);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.A != null ? OurContext.GetIdFromProxy(this.Proxy.A) : (int?)null);
            binStream.Write(this.Proxy.B != null ? OurContext.GetIdFromProxy(this.Proxy.B) : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            binStream.Read(out this._fk_A);
            binStream.Read(out this._fk_B);
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(ASide_connectsTo_BSide_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (ASide_connectsTo_BSide_RelationEntryNHibernateImpl)obj;
            var me = (ASide_connectsTo_BSide_RelationEntryNHibernateImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_A.HasValue)
                this.A = ((Zetbox.App.Test.N_to_M_relations_ANHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Test.N_to_M_relations_A>(_fk_A.Value));
            else
                this.A = null;

            if (_fk_B.HasValue)
                this.B = ((Zetbox.App.Test.N_to_M_relations_BNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Test.N_to_M_relations_B>(_fk_B.Value));
            else
                this.B = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }

        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow A
            if (this.A != null && this.A.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.A);
                ((NHibernatePersistenceObject)this.A).ChildrenToDelete.Add(this);
            }

            // Follow B
            if (this.B != null && this.B.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.B);
                ((NHibernatePersistenceObject)this.B).ChildrenToDelete.Add(this);
            }

            // remove from collections manually to notify NHibernate if necessary
            if (this.A != null && this.A.BSide.Contains(this.B)) this.A.BSide.Remove(this.B);
            else
            // The other direction is handled by the infrastructure (but A might be null)
            if (this.B != null && this.B.ASide.Contains(this.A)) this.B.ASide.Remove(this.A);

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.A = null;
            this.B = null;
        }

        public class ASide_connectsTo_BSide_RelationEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public ASide_connectsTo_BSide_RelationEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(ASide_connectsTo_BSide_RelationEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(ASide_connectsTo_BSide_RelationEntryProxy); } }

            public virtual Zetbox.App.Test.N_to_M_relations_ANHibernateImpl.N_to_M_relations_AProxy A { get; set; }

            public virtual Zetbox.App.Test.N_to_M_relations_BNHibernateImpl.N_to_M_relations_BProxy B { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.Base
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("CalculatedReference_dependsOn_InputProperties_RelationEntryNHibernateImpl")]
    public class CalculatedReference_dependsOn_InputProperties_RelationEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.RelationEntryNHibernateImpl<Zetbox.App.Base.CalculatedObjectReferenceProperty, Zetbox.App.Base.CalculatedObjectReferencePropertyNHibernateImpl, Zetbox.App.Base.Property, Zetbox.App.Base.PropertyNHibernateImpl>, CalculatedReference_dependsOn_InputProperties_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        public CalculatedReference_dependsOn_InputProperties_RelationEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public CalculatedReference_dependsOn_InputProperties_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new CalculatedReference_dependsOn_InputProperties_RelationEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public CalculatedReference_dependsOn_InputProperties_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, CalculatedReference_dependsOn_InputProperties_RelationEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly CalculatedReference_dependsOn_InputProperties_RelationEntryProxy Proxy;

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.ExportGuid;
                if (this.Proxy.ExportGuid == Guid.Empty) {
                    __result = this.Proxy.ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.ExportGuid != value)
                {
                    var __oldValue = Proxy.ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    Proxy.ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("47595643-e8d0-48ef-82c7-2d24de8a784e");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Base.CalculatedObjectReferenceProperty)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Property)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=this.Proxy.A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Base.CalculatedObjectReferenceProperty; moduleNamespace=Zetbox.App.Base;
        // will get inverse collection for notifications for Inputs
        // PositionStorage=none;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.CalculatedObjectReferenceProperty A
        {
            get
            {
                Zetbox.App.Base.CalculatedObjectReferencePropertyNHibernateImpl __value = (Zetbox.App.Base.CalculatedObjectReferencePropertyNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.A == null)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Base.CalculatedObjectReferencePropertyNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);
                var __newValue = (Zetbox.App.Base.CalculatedObjectReferencePropertyNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("Inputs", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("Inputs", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.A = null;
                }
                else
                {
                    this.Proxy.A = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.Inputs as IRelationListSync<Zetbox.App.Base.CalculatedReference_dependsOn_InputProperties_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.Inputs as IRelationListSync<Zetbox.App.Base.CalculatedReference_dependsOn_InputProperties_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for A's id, used on dehydration only</summary>
        private int? _fk_A = null;

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return A != null ? A.ID : (int?)null; }
			set { _fk_A = value; }
		}

        /// <summary>Backing store for A's guid, used on import only</summary>
        private Guid? _fk_guid_A = null;

    public Zetbox.API.Async.ZbTask TriggerFetchAAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Base.CalculatedObjectReferenceProperty>(this.A);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=this.Proxy.B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Property; moduleNamespace=Zetbox.App.Base;
        // no inverse navigator handling
        // PositionStorage=none;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.Property B
        {
            get
            {
                Zetbox.App.Base.PropertyNHibernateImpl __value = (Zetbox.App.Base.PropertyNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.B == null)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Base.PropertyNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);
                var __newValue = (Zetbox.App.Base.PropertyNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.B = null;
                }
                else
                {
                    this.Proxy.B = __newValue.Proxy;
                }

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for B's id, used on dehydration only</summary>
        private int? _fk_B = null;

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return B != null ? B.ID : (int?)null; }
			set { _fk_B = value; }
		}

        /// <summary>Backing store for B's guid, used on import only</summary>
        private Guid? _fk_guid_B = null;

    public Zetbox.API.Async.ZbTask TriggerFetchBAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Property>(this.B);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.ExportGuid);
            binStream.Write(this.Proxy.A != null ? OurContext.GetIdFromProxy(this.Proxy.A) : (int?)null);
            binStream.Write(this.Proxy.B != null ? OurContext.GetIdFromProxy(this.Proxy.B) : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this.Proxy.ExportGuid = binStream.ReadGuid();
            binStream.Read(out this._fk_A);
            binStream.Read(out this._fk_B);
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", this.Proxy.ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(this.Proxy.A != null ? this.Proxy.A.ExportGuid : (Guid?)null, xml, "A", "Zetbox.App.Base");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(this.Proxy.B != null ? this.Proxy.B.ExportGuid : (Guid?)null, xml, "B", "Zetbox.App.Base");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "Zetbox.App.Base|ExportGuid":
                this.Proxy.ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "Zetbox.App.Base|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.Base|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(CalculatedReference_dependsOn_InputProperties_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (CalculatedReference_dependsOn_InputProperties_RelationEntryNHibernateImpl)obj;
            var me = (CalculatedReference_dependsOn_InputProperties_RelationEntryNHibernateImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                this.A = ((Zetbox.App.Base.CalculatedObjectReferencePropertyNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.CalculatedObjectReferenceProperty>(_fk_guid_A.Value));
            else
            if (_fk_A.HasValue)
                this.A = ((Zetbox.App.Base.CalculatedObjectReferencePropertyNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.CalculatedObjectReferenceProperty>(_fk_A.Value));
            else
                this.A = null;

            if (_fk_guid_B.HasValue)
                this.B = ((Zetbox.App.Base.PropertyNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Property>(_fk_guid_B.Value));
            else
            if (_fk_B.HasValue)
                this.B = ((Zetbox.App.Base.PropertyNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Property>(_fk_B.Value));
            else
                this.B = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }

        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow A
            if (this.A != null && this.A.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.A);
                ((NHibernatePersistenceObject)this.A).ChildrenToDelete.Add(this);
            }

            // Follow B
            if (this.B != null && this.B.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.B);
                ((NHibernatePersistenceObject)this.B).ChildrenToDelete.Add(this);
            }

            // remove from collections manually to notify NHibernate if necessary
            if (this.A != null && this.A.Inputs.Contains(this.B)) this.A.Inputs.Remove(this.B);

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.A = null;
            this.B = null;
        }

        public class CalculatedReference_dependsOn_InputProperties_RelationEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public CalculatedReference_dependsOn_InputProperties_RelationEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(CalculatedReference_dependsOn_InputProperties_RelationEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(CalculatedReference_dependsOn_InputProperties_RelationEntryProxy); } }

            public virtual Zetbox.App.Base.CalculatedObjectReferencePropertyNHibernateImpl.CalculatedObjectReferencePropertyProxy A { get; set; }

            public virtual Zetbox.App.Base.PropertyNHibernateImpl.PropertyProxy B { get; set; }

            public virtual Guid ExportGuid { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.Calendar
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("Calendar_shared_r_GroupReaders_RelationEntryNHibernateImpl")]
    public class Calendar_shared_r_GroupReaders_RelationEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.RelationEntryNHibernateImpl<Zetbox.App.Calendar.CalendarBook, Zetbox.App.Calendar.CalendarBookNHibernateImpl, Zetbox.App.Base.Group, Zetbox.App.Base.GroupNHibernateImpl>, Calendar_shared_r_GroupReaders_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        public Calendar_shared_r_GroupReaders_RelationEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public Calendar_shared_r_GroupReaders_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new Calendar_shared_r_GroupReaders_RelationEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public Calendar_shared_r_GroupReaders_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, Calendar_shared_r_GroupReaders_RelationEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly Calendar_shared_r_GroupReaders_RelationEntryProxy Proxy;

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.ExportGuid;
                if (this.Proxy.ExportGuid == Guid.Empty) {
                    __result = this.Proxy.ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.ExportGuid != value)
                {
                    var __oldValue = Proxy.ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    Proxy.ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("775789a3-032e-478e-a01e-ec9f51580c5d");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Calendar.CalendarBook)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Group)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=this.Proxy.A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Calendar.CalendarBook; moduleNamespace=Zetbox.App.Calendar;
        // will get inverse collection for notifications for GroupReaders
        // PositionStorage=none;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Calendar.CalendarBook A
        {
            get
            {
                Zetbox.App.Calendar.CalendarBookNHibernateImpl __value = (Zetbox.App.Calendar.CalendarBookNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.A == null)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Calendar.CalendarBookNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);
                var __newValue = (Zetbox.App.Calendar.CalendarBookNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("GroupReaders", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("GroupReaders", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.A = null;
                }
                else
                {
                    this.Proxy.A = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.GroupReaders as IRelationListSync<Zetbox.App.Calendar.Calendar_shared_r_GroupReaders_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.GroupReaders as IRelationListSync<Zetbox.App.Calendar.Calendar_shared_r_GroupReaders_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for A's id, used on dehydration only</summary>
        private int? _fk_A = null;

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return A != null ? A.ID : (int?)null; }
			set { _fk_A = value; }
		}

        /// <summary>Backing store for A's guid, used on import only</summary>
        private Guid? _fk_guid_A = null;

    public Zetbox.API.Async.ZbTask TriggerFetchAAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Calendar.CalendarBook>(this.A);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=this.Proxy.B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Group; moduleNamespace=Zetbox.App.Calendar;
        // no inverse navigator handling
        // PositionStorage=none;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.Group B
        {
            get
            {
                Zetbox.App.Base.GroupNHibernateImpl __value = (Zetbox.App.Base.GroupNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.B == null)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Base.GroupNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);
                var __newValue = (Zetbox.App.Base.GroupNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.B = null;
                }
                else
                {
                    this.Proxy.B = __newValue.Proxy;
                }

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for B's id, used on dehydration only</summary>
        private int? _fk_B = null;

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return B != null ? B.ID : (int?)null; }
			set { _fk_B = value; }
		}

        /// <summary>Backing store for B's guid, used on import only</summary>
        private Guid? _fk_guid_B = null;

    public Zetbox.API.Async.ZbTask TriggerFetchBAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Group>(this.B);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.ExportGuid);
            binStream.Write(this.Proxy.A != null ? OurContext.GetIdFromProxy(this.Proxy.A) : (int?)null);
            binStream.Write(this.Proxy.B != null ? OurContext.GetIdFromProxy(this.Proxy.B) : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this.Proxy.ExportGuid = binStream.ReadGuid();
            binStream.Read(out this._fk_A);
            binStream.Read(out this._fk_B);
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", this.Proxy.ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Calendar")) XmlStreamer.ToStream(this.Proxy.A != null ? this.Proxy.A.ExportGuid : (Guid?)null, xml, "A", "Zetbox.App.Calendar");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Calendar")) XmlStreamer.ToStream(this.Proxy.B != null ? this.Proxy.B.ExportGuid : (Guid?)null, xml, "B", "Zetbox.App.Calendar");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "Zetbox.App.Calendar|ExportGuid":
                this.Proxy.ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "Zetbox.App.Calendar|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.Calendar|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Calendar_shared_r_GroupReaders_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Calendar_shared_r_GroupReaders_RelationEntryNHibernateImpl)obj;
            var me = (Calendar_shared_r_GroupReaders_RelationEntryNHibernateImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                this.A = ((Zetbox.App.Calendar.CalendarBookNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Calendar.CalendarBook>(_fk_guid_A.Value));
            else
            if (_fk_A.HasValue)
                this.A = ((Zetbox.App.Calendar.CalendarBookNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Calendar.CalendarBook>(_fk_A.Value));
            else
                this.A = null;

            if (_fk_guid_B.HasValue)
                this.B = ((Zetbox.App.Base.GroupNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Group>(_fk_guid_B.Value));
            else
            if (_fk_B.HasValue)
                this.B = ((Zetbox.App.Base.GroupNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Group>(_fk_B.Value));
            else
                this.B = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }

        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow A
            if (this.A != null && this.A.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.A);
                ((NHibernatePersistenceObject)this.A).ChildrenToDelete.Add(this);
            }

            // Follow B
            if (this.B != null && this.B.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.B);
                ((NHibernatePersistenceObject)this.B).ChildrenToDelete.Add(this);
            }

            // remove from collections manually to notify NHibernate if necessary
            if (this.A != null && this.A.GroupReaders.Contains(this.B)) this.A.GroupReaders.Remove(this.B);

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.A = null;
            this.B = null;
        }

        public class Calendar_shared_r_GroupReaders_RelationEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public Calendar_shared_r_GroupReaders_RelationEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(Calendar_shared_r_GroupReaders_RelationEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(Calendar_shared_r_GroupReaders_RelationEntryProxy); } }

            public virtual Zetbox.App.Calendar.CalendarBookNHibernateImpl.CalendarBookProxy A { get; set; }

            public virtual Zetbox.App.Base.GroupNHibernateImpl.GroupProxy B { get; set; }

            public virtual Guid ExportGuid { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.Calendar
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("Calendar_shared_r_Readers_RelationEntryNHibernateImpl")]
    public class Calendar_shared_r_Readers_RelationEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.RelationEntryNHibernateImpl<Zetbox.App.Calendar.CalendarBook, Zetbox.App.Calendar.CalendarBookNHibernateImpl, Zetbox.App.Base.Identity, Zetbox.App.Base.IdentityNHibernateImpl>, Calendar_shared_r_Readers_RelationEntry
    {
        public Calendar_shared_r_Readers_RelationEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public Calendar_shared_r_Readers_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new Calendar_shared_r_Readers_RelationEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public Calendar_shared_r_Readers_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, Calendar_shared_r_Readers_RelationEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly Calendar_shared_r_Readers_RelationEntryProxy Proxy;
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("385c829b-02d6-48d0-8184-b3b5df6c25be");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Calendar.CalendarBook)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Identity)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=this.Proxy.A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Calendar.CalendarBook; moduleNamespace=Zetbox.App.Calendar;
        // will get inverse collection for notifications for Readers
        // PositionStorage=none;
        // Target not exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Calendar.CalendarBook A
        {
            get
            {
                Zetbox.App.Calendar.CalendarBookNHibernateImpl __value = (Zetbox.App.Calendar.CalendarBookNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.A == null)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Calendar.CalendarBookNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);
                var __newValue = (Zetbox.App.Calendar.CalendarBookNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("Readers", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("Readers", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.A = null;
                }
                else
                {
                    this.Proxy.A = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.Readers as IRelationListSync<Zetbox.App.Calendar.Calendar_shared_r_Readers_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.Readers as IRelationListSync<Zetbox.App.Calendar.Calendar_shared_r_Readers_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for A's id, used on dehydration only</summary>
        private int? _fk_A = null;

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return A != null ? A.ID : (int?)null; }
			set { _fk_A = value; }
		}


    public Zetbox.API.Async.ZbTask TriggerFetchAAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Calendar.CalendarBook>(this.A);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=this.Proxy.B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Identity; moduleNamespace=Zetbox.App.Calendar;
        // no inverse navigator handling
        // PositionStorage=none;
        // Target not exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.Identity B
        {
            get
            {
                Zetbox.App.Base.IdentityNHibernateImpl __value = (Zetbox.App.Base.IdentityNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.B == null)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Base.IdentityNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);
                var __newValue = (Zetbox.App.Base.IdentityNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.B = null;
                }
                else
                {
                    this.Proxy.B = __newValue.Proxy;
                }

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for B's id, used on dehydration only</summary>
        private int? _fk_B = null;

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return B != null ? B.ID : (int?)null; }
			set { _fk_B = value; }
		}


    public Zetbox.API.Async.ZbTask TriggerFetchBAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Identity>(this.B);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.A != null ? OurContext.GetIdFromProxy(this.Proxy.A) : (int?)null);
            binStream.Write(this.Proxy.B != null ? OurContext.GetIdFromProxy(this.Proxy.B) : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            binStream.Read(out this._fk_A);
            binStream.Read(out this._fk_B);
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Calendar_shared_r_Readers_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Calendar_shared_r_Readers_RelationEntryNHibernateImpl)obj;
            var me = (Calendar_shared_r_Readers_RelationEntryNHibernateImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_A.HasValue)
                this.A = ((Zetbox.App.Calendar.CalendarBookNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Calendar.CalendarBook>(_fk_A.Value));
            else
                this.A = null;

            if (_fk_B.HasValue)
                this.B = ((Zetbox.App.Base.IdentityNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Identity>(_fk_B.Value));
            else
                this.B = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }

        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow A
            if (this.A != null && this.A.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.A);
                ((NHibernatePersistenceObject)this.A).ChildrenToDelete.Add(this);
            }

            // Follow B
            if (this.B != null && this.B.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.B);
                ((NHibernatePersistenceObject)this.B).ChildrenToDelete.Add(this);
            }

            // remove from collections manually to notify NHibernate if necessary
            if (this.A != null && this.A.Readers.Contains(this.B)) this.A.Readers.Remove(this.B);

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.A = null;
            this.B = null;
        }

        public class Calendar_shared_r_Readers_RelationEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public Calendar_shared_r_Readers_RelationEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(Calendar_shared_r_Readers_RelationEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(Calendar_shared_r_Readers_RelationEntryProxy); } }

            public virtual Zetbox.App.Calendar.CalendarBookNHibernateImpl.CalendarBookProxy A { get; set; }

            public virtual Zetbox.App.Base.IdentityNHibernateImpl.IdentityProxy B { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.Calendar
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("Calendar_shared_w_GroupWriters_RelationEntryNHibernateImpl")]
    public class Calendar_shared_w_GroupWriters_RelationEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.RelationEntryNHibernateImpl<Zetbox.App.Calendar.CalendarBook, Zetbox.App.Calendar.CalendarBookNHibernateImpl, Zetbox.App.Base.Group, Zetbox.App.Base.GroupNHibernateImpl>, Calendar_shared_w_GroupWriters_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        public Calendar_shared_w_GroupWriters_RelationEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public Calendar_shared_w_GroupWriters_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new Calendar_shared_w_GroupWriters_RelationEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public Calendar_shared_w_GroupWriters_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, Calendar_shared_w_GroupWriters_RelationEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly Calendar_shared_w_GroupWriters_RelationEntryProxy Proxy;

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.ExportGuid;
                if (this.Proxy.ExportGuid == Guid.Empty) {
                    __result = this.Proxy.ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.ExportGuid != value)
                {
                    var __oldValue = Proxy.ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    Proxy.ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("93f20ca2-6935-41bc-8f80-7a441b3cf69d");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Calendar.CalendarBook)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Group)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=this.Proxy.A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Calendar.CalendarBook; moduleNamespace=Zetbox.App.Calendar;
        // will get inverse collection for notifications for GroupWriters
        // PositionStorage=none;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Calendar.CalendarBook A
        {
            get
            {
                Zetbox.App.Calendar.CalendarBookNHibernateImpl __value = (Zetbox.App.Calendar.CalendarBookNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.A == null)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Calendar.CalendarBookNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);
                var __newValue = (Zetbox.App.Calendar.CalendarBookNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("GroupWriters", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("GroupWriters", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.A = null;
                }
                else
                {
                    this.Proxy.A = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.GroupWriters as IRelationListSync<Zetbox.App.Calendar.Calendar_shared_w_GroupWriters_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.GroupWriters as IRelationListSync<Zetbox.App.Calendar.Calendar_shared_w_GroupWriters_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for A's id, used on dehydration only</summary>
        private int? _fk_A = null;

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return A != null ? A.ID : (int?)null; }
			set { _fk_A = value; }
		}

        /// <summary>Backing store for A's guid, used on import only</summary>
        private Guid? _fk_guid_A = null;

    public Zetbox.API.Async.ZbTask TriggerFetchAAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Calendar.CalendarBook>(this.A);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=this.Proxy.B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Group; moduleNamespace=Zetbox.App.Calendar;
        // no inverse navigator handling
        // PositionStorage=none;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.Group B
        {
            get
            {
                Zetbox.App.Base.GroupNHibernateImpl __value = (Zetbox.App.Base.GroupNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.B == null)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Base.GroupNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);
                var __newValue = (Zetbox.App.Base.GroupNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.B = null;
                }
                else
                {
                    this.Proxy.B = __newValue.Proxy;
                }

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for B's id, used on dehydration only</summary>
        private int? _fk_B = null;

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return B != null ? B.ID : (int?)null; }
			set { _fk_B = value; }
		}

        /// <summary>Backing store for B's guid, used on import only</summary>
        private Guid? _fk_guid_B = null;

    public Zetbox.API.Async.ZbTask TriggerFetchBAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Group>(this.B);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.ExportGuid);
            binStream.Write(this.Proxy.A != null ? OurContext.GetIdFromProxy(this.Proxy.A) : (int?)null);
            binStream.Write(this.Proxy.B != null ? OurContext.GetIdFromProxy(this.Proxy.B) : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this.Proxy.ExportGuid = binStream.ReadGuid();
            binStream.Read(out this._fk_A);
            binStream.Read(out this._fk_B);
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", this.Proxy.ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Calendar")) XmlStreamer.ToStream(this.Proxy.A != null ? this.Proxy.A.ExportGuid : (Guid?)null, xml, "A", "Zetbox.App.Calendar");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Calendar")) XmlStreamer.ToStream(this.Proxy.B != null ? this.Proxy.B.ExportGuid : (Guid?)null, xml, "B", "Zetbox.App.Calendar");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "Zetbox.App.Calendar|ExportGuid":
                this.Proxy.ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "Zetbox.App.Calendar|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.Calendar|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Calendar_shared_w_GroupWriters_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Calendar_shared_w_GroupWriters_RelationEntryNHibernateImpl)obj;
            var me = (Calendar_shared_w_GroupWriters_RelationEntryNHibernateImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                this.A = ((Zetbox.App.Calendar.CalendarBookNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Calendar.CalendarBook>(_fk_guid_A.Value));
            else
            if (_fk_A.HasValue)
                this.A = ((Zetbox.App.Calendar.CalendarBookNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Calendar.CalendarBook>(_fk_A.Value));
            else
                this.A = null;

            if (_fk_guid_B.HasValue)
                this.B = ((Zetbox.App.Base.GroupNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Group>(_fk_guid_B.Value));
            else
            if (_fk_B.HasValue)
                this.B = ((Zetbox.App.Base.GroupNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Group>(_fk_B.Value));
            else
                this.B = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }

        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow A
            if (this.A != null && this.A.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.A);
                ((NHibernatePersistenceObject)this.A).ChildrenToDelete.Add(this);
            }

            // Follow B
            if (this.B != null && this.B.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.B);
                ((NHibernatePersistenceObject)this.B).ChildrenToDelete.Add(this);
            }

            // remove from collections manually to notify NHibernate if necessary
            if (this.A != null && this.A.GroupWriters.Contains(this.B)) this.A.GroupWriters.Remove(this.B);

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.A = null;
            this.B = null;
        }

        public class Calendar_shared_w_GroupWriters_RelationEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public Calendar_shared_w_GroupWriters_RelationEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(Calendar_shared_w_GroupWriters_RelationEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(Calendar_shared_w_GroupWriters_RelationEntryProxy); } }

            public virtual Zetbox.App.Calendar.CalendarBookNHibernateImpl.CalendarBookProxy A { get; set; }

            public virtual Zetbox.App.Base.GroupNHibernateImpl.GroupProxy B { get; set; }

            public virtual Guid ExportGuid { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.Calendar
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("Calendar_shared_w_Writers_RelationEntryNHibernateImpl")]
    public class Calendar_shared_w_Writers_RelationEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.RelationEntryNHibernateImpl<Zetbox.App.Calendar.CalendarBook, Zetbox.App.Calendar.CalendarBookNHibernateImpl, Zetbox.App.Base.Identity, Zetbox.App.Base.IdentityNHibernateImpl>, Calendar_shared_w_Writers_RelationEntry
    {
        public Calendar_shared_w_Writers_RelationEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public Calendar_shared_w_Writers_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new Calendar_shared_w_Writers_RelationEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public Calendar_shared_w_Writers_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, Calendar_shared_w_Writers_RelationEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly Calendar_shared_w_Writers_RelationEntryProxy Proxy;
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("af8843f9-0085-47ec-bcb6-f0f8a22a2c03");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Calendar.CalendarBook)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Identity)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=this.Proxy.A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Calendar.CalendarBook; moduleNamespace=Zetbox.App.Calendar;
        // will get inverse collection for notifications for Writers
        // PositionStorage=none;
        // Target not exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Calendar.CalendarBook A
        {
            get
            {
                Zetbox.App.Calendar.CalendarBookNHibernateImpl __value = (Zetbox.App.Calendar.CalendarBookNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.A == null)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Calendar.CalendarBookNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);
                var __newValue = (Zetbox.App.Calendar.CalendarBookNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("Writers", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("Writers", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.A = null;
                }
                else
                {
                    this.Proxy.A = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.Writers as IRelationListSync<Zetbox.App.Calendar.Calendar_shared_w_Writers_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.Writers as IRelationListSync<Zetbox.App.Calendar.Calendar_shared_w_Writers_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for A's id, used on dehydration only</summary>
        private int? _fk_A = null;

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return A != null ? A.ID : (int?)null; }
			set { _fk_A = value; }
		}


    public Zetbox.API.Async.ZbTask TriggerFetchAAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Calendar.CalendarBook>(this.A);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=this.Proxy.B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Identity; moduleNamespace=Zetbox.App.Calendar;
        // no inverse navigator handling
        // PositionStorage=none;
        // Target not exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.Identity B
        {
            get
            {
                Zetbox.App.Base.IdentityNHibernateImpl __value = (Zetbox.App.Base.IdentityNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.B == null)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Base.IdentityNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);
                var __newValue = (Zetbox.App.Base.IdentityNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.B = null;
                }
                else
                {
                    this.Proxy.B = __newValue.Proxy;
                }

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for B's id, used on dehydration only</summary>
        private int? _fk_B = null;

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return B != null ? B.ID : (int?)null; }
			set { _fk_B = value; }
		}


    public Zetbox.API.Async.ZbTask TriggerFetchBAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Identity>(this.B);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.A != null ? OurContext.GetIdFromProxy(this.Proxy.A) : (int?)null);
            binStream.Write(this.Proxy.B != null ? OurContext.GetIdFromProxy(this.Proxy.B) : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            binStream.Read(out this._fk_A);
            binStream.Read(out this._fk_B);
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Calendar_shared_w_Writers_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Calendar_shared_w_Writers_RelationEntryNHibernateImpl)obj;
            var me = (Calendar_shared_w_Writers_RelationEntryNHibernateImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_A.HasValue)
                this.A = ((Zetbox.App.Calendar.CalendarBookNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Calendar.CalendarBook>(_fk_A.Value));
            else
                this.A = null;

            if (_fk_B.HasValue)
                this.B = ((Zetbox.App.Base.IdentityNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Identity>(_fk_B.Value));
            else
                this.B = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }

        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow A
            if (this.A != null && this.A.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.A);
                ((NHibernatePersistenceObject)this.A).ChildrenToDelete.Add(this);
            }

            // Follow B
            if (this.B != null && this.B.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.B);
                ((NHibernatePersistenceObject)this.B).ChildrenToDelete.Add(this);
            }

            // remove from collections manually to notify NHibernate if necessary
            if (this.A != null && this.A.Writers.Contains(this.B)) this.A.Writers.Remove(this.B);

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.A = null;
            this.B = null;
        }

        public class Calendar_shared_w_Writers_RelationEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public Calendar_shared_w_Writers_RelationEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(Calendar_shared_w_Writers_RelationEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(Calendar_shared_w_Writers_RelationEntryProxy); } }

            public virtual Zetbox.App.Calendar.CalendarBookNHibernateImpl.CalendarBookProxy A { get; set; }

            public virtual Zetbox.App.Base.IdentityNHibernateImpl.IdentityProxy B { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.Base
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("DataType_implements_ImplementedInterfaces_RelationEntryNHibernateImpl")]
    public class DataType_implements_ImplementedInterfaces_RelationEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.RelationEntryNHibernateImpl<Zetbox.App.Base.DataType, Zetbox.App.Base.DataTypeNHibernateImpl, Zetbox.App.Base.Interface, Zetbox.App.Base.InterfaceNHibernateImpl>, DataType_implements_ImplementedInterfaces_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        public DataType_implements_ImplementedInterfaces_RelationEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public DataType_implements_ImplementedInterfaces_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new DataType_implements_ImplementedInterfaces_RelationEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public DataType_implements_ImplementedInterfaces_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, DataType_implements_ImplementedInterfaces_RelationEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly DataType_implements_ImplementedInterfaces_RelationEntryProxy Proxy;

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.ExportGuid;
                if (this.Proxy.ExportGuid == Guid.Empty) {
                    __result = this.Proxy.ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.ExportGuid != value)
                {
                    var __oldValue = Proxy.ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    Proxy.ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("692c1064-37a2-4be3-a81e-4cb91f673aa3");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Base.DataType)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Interface)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=this.Proxy.A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Base.DataType; moduleNamespace=Zetbox.App.Base;
        // will get inverse collection for notifications for ImplementsInterfaces
        // PositionStorage=none;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.DataType A
        {
            get
            {
                Zetbox.App.Base.DataTypeNHibernateImpl __value = (Zetbox.App.Base.DataTypeNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.A == null)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Base.DataTypeNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);
                var __newValue = (Zetbox.App.Base.DataTypeNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("ImplementsInterfaces", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("ImplementsInterfaces", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.A = null;
                }
                else
                {
                    this.Proxy.A = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.ImplementsInterfaces as IRelationListSync<Zetbox.App.Base.DataType_implements_ImplementedInterfaces_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.ImplementsInterfaces as IRelationListSync<Zetbox.App.Base.DataType_implements_ImplementedInterfaces_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for A's id, used on dehydration only</summary>
        private int? _fk_A = null;

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return A != null ? A.ID : (int?)null; }
			set { _fk_A = value; }
		}

        /// <summary>Backing store for A's guid, used on import only</summary>
        private Guid? _fk_guid_A = null;

    public Zetbox.API.Async.ZbTask TriggerFetchAAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Base.DataType>(this.A);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=this.Proxy.B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Interface; moduleNamespace=Zetbox.App.Base;
        // no inverse navigator handling
        // PositionStorage=none;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.Interface B
        {
            get
            {
                Zetbox.App.Base.InterfaceNHibernateImpl __value = (Zetbox.App.Base.InterfaceNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.B == null)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Base.InterfaceNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);
                var __newValue = (Zetbox.App.Base.InterfaceNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.B = null;
                }
                else
                {
                    this.Proxy.B = __newValue.Proxy;
                }

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for B's id, used on dehydration only</summary>
        private int? _fk_B = null;

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return B != null ? B.ID : (int?)null; }
			set { _fk_B = value; }
		}

        /// <summary>Backing store for B's guid, used on import only</summary>
        private Guid? _fk_guid_B = null;

    public Zetbox.API.Async.ZbTask TriggerFetchBAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Interface>(this.B);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.ExportGuid);
            binStream.Write(this.Proxy.A != null ? OurContext.GetIdFromProxy(this.Proxy.A) : (int?)null);
            binStream.Write(this.Proxy.B != null ? OurContext.GetIdFromProxy(this.Proxy.B) : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this.Proxy.ExportGuid = binStream.ReadGuid();
            binStream.Read(out this._fk_A);
            binStream.Read(out this._fk_B);
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", this.Proxy.ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(this.Proxy.A != null ? this.Proxy.A.ExportGuid : (Guid?)null, xml, "A", "Zetbox.App.Base");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(this.Proxy.B != null ? this.Proxy.B.ExportGuid : (Guid?)null, xml, "B", "Zetbox.App.Base");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "Zetbox.App.Base|ExportGuid":
                this.Proxy.ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "Zetbox.App.Base|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.Base|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(DataType_implements_ImplementedInterfaces_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (DataType_implements_ImplementedInterfaces_RelationEntryNHibernateImpl)obj;
            var me = (DataType_implements_ImplementedInterfaces_RelationEntryNHibernateImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                this.A = ((Zetbox.App.Base.DataTypeNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.DataType>(_fk_guid_A.Value));
            else
            if (_fk_A.HasValue)
                this.A = ((Zetbox.App.Base.DataTypeNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.DataType>(_fk_A.Value));
            else
                this.A = null;

            if (_fk_guid_B.HasValue)
                this.B = ((Zetbox.App.Base.InterfaceNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Interface>(_fk_guid_B.Value));
            else
            if (_fk_B.HasValue)
                this.B = ((Zetbox.App.Base.InterfaceNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Interface>(_fk_B.Value));
            else
                this.B = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }

        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow A
            if (this.A != null && this.A.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.A);
                ((NHibernatePersistenceObject)this.A).ChildrenToDelete.Add(this);
            }

            // Follow B
            if (this.B != null && this.B.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.B);
                ((NHibernatePersistenceObject)this.B).ChildrenToDelete.Add(this);
            }

            // remove from collections manually to notify NHibernate if necessary
            if (this.A != null && this.A.ImplementsInterfaces.Contains(this.B)) this.A.ImplementsInterfaces.Remove(this.B);

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.A = null;
            this.B = null;
        }

        public class DataType_implements_ImplementedInterfaces_RelationEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public DataType_implements_ImplementedInterfaces_RelationEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(DataType_implements_ImplementedInterfaces_RelationEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(DataType_implements_ImplementedInterfaces_RelationEntryProxy); } }

            public virtual Zetbox.App.Base.DataTypeNHibernateImpl.DataTypeProxy A { get; set; }

            public virtual Zetbox.App.Base.InterfaceNHibernateImpl.InterfaceProxy B { get; set; }

            public virtual Guid ExportGuid { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
}

namespace at.dasz.DocumentManagement
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("Document_has_Revisions_RelationEntryNHibernateImpl")]
    public class Document_has_Revisions_RelationEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.RelationEntryNHibernateImpl<at.dasz.DocumentManagement.File, at.dasz.DocumentManagement.FileNHibernateImpl, Zetbox.App.Base.Blob, Zetbox.App.Base.BlobNHibernateImpl>, Document_has_Revisions_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        public Document_has_Revisions_RelationEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public Document_has_Revisions_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new Document_has_Revisions_RelationEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public Document_has_Revisions_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, Document_has_Revisions_RelationEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly Document_has_Revisions_RelationEntryProxy Proxy;

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.ExportGuid;
                if (this.Proxy.ExportGuid == Guid.Empty) {
                    __result = this.Proxy.ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.ExportGuid != value)
                {
                    var __oldValue = Proxy.ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    Proxy.ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("69d27812-e981-443b-a94b-dfe1a95f3aad");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (at.dasz.DocumentManagement.File)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Blob)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=this.Proxy.A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=at.dasz.DocumentManagement.File; moduleNamespace=at.dasz.DocumentManagement;
        // will get inverse collection for notifications for Revisions
        // PositionStorage=A_pos;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public at.dasz.DocumentManagement.File A
        {
            get
            {
                at.dasz.DocumentManagement.FileNHibernateImpl __value = (at.dasz.DocumentManagement.FileNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.A == null)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (at.dasz.DocumentManagement.FileNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);
                var __newValue = (at.dasz.DocumentManagement.FileNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("Revisions", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("Revisions", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.A = null;
                }
                else
                {
                    this.Proxy.A = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.Revisions as IRelationListSync<at.dasz.DocumentManagement.Document_has_Revisions_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.Revisions as IRelationListSync<at.dasz.DocumentManagement.Document_has_Revisions_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for A's id, used on dehydration only</summary>
        private int? _fk_A = null;

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return A != null ? A.ID : (int?)null; }
			set { _fk_A = value; }
		}

        /// <summary>Backing store for A's guid, used on import only</summary>
        private Guid? _fk_guid_A = null;

    public Zetbox.API.Async.ZbTask TriggerFetchAAsync()
    {
        return new Zetbox.API.Async.ZbTask<at.dasz.DocumentManagement.File>(this.A);
    }

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        public virtual int? A_pos
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.A_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.A_pos != value)
                {
                    var __oldValue = Proxy.A_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("A_pos", __oldValue, __newValue);
                    Proxy.A_pos = __newValue;
                    NotifyPropertyChanged("A_pos", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("A_pos");
                }
            }
        }
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=this.Proxy.B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Blob; moduleNamespace=at.dasz.DocumentManagement;
        // no inverse navigator handling
        // PositionStorage=B_pos;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.Blob B
        {
            get
            {
                Zetbox.App.Base.BlobNHibernateImpl __value = (Zetbox.App.Base.BlobNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.B == null)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Base.BlobNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);
                var __newValue = (Zetbox.App.Base.BlobNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.B = null;
                }
                else
                {
                    this.Proxy.B = __newValue.Proxy;
                }

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for B's id, used on dehydration only</summary>
        private int? _fk_B = null;

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return B != null ? B.ID : (int?)null; }
			set { _fk_B = value; }
		}

        /// <summary>Backing store for B's guid, used on import only</summary>
        private Guid? _fk_guid_B = null;

    public Zetbox.API.Async.ZbTask TriggerFetchBAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Blob>(this.B);
    }

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        public virtual int? B_pos
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.B_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.B_pos != value)
                {
                    var __oldValue = Proxy.B_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("B_pos", __oldValue, __newValue);
                    Proxy.B_pos = __newValue;
                    NotifyPropertyChanged("B_pos", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("B_pos");
                }
            }
        }
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        /// <summary>
        /// Index into the A-side list of this relation
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public int? AIndex
        {
            get { return this.A_pos; }
            set { this.A_pos = (int?)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        /// <summary>
        /// Index into the B-side list of this relation
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public int? BIndex
        {
            get { return this.B_pos; }
            set { this.B_pos = (int?)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.ExportGuid);
            binStream.Write(this.Proxy.A != null ? OurContext.GetIdFromProxy(this.Proxy.A) : (int?)null);
            binStream.Write(this.Proxy.A_pos);
            binStream.Write(this.Proxy.B != null ? OurContext.GetIdFromProxy(this.Proxy.B) : (int?)null);
            binStream.Write(this.Proxy.B_pos);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this.Proxy.ExportGuid = binStream.ReadGuid();
            binStream.Read(out this._fk_A);
            this.Proxy.A_pos = binStream.ReadNullableInt32();
            binStream.Read(out this._fk_B);
            this.Proxy.B_pos = binStream.ReadNullableInt32();
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", this.Proxy.ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("at.dasz.DocumentManagement")) XmlStreamer.ToStream(this.Proxy.A != null ? this.Proxy.A.ExportGuid : (Guid?)null, xml, "A", "at.dasz.DocumentManagement");
            if (modules.Contains("*") || modules.Contains("at.dasz.DocumentManagement")) XmlStreamer.ToStream(this.Proxy.A_pos, xml, "A_pos", "at.dasz.DocumentManagement");
            if (modules.Contains("*") || modules.Contains("at.dasz.DocumentManagement")) XmlStreamer.ToStream(this.Proxy.B != null ? this.Proxy.B.ExportGuid : (Guid?)null, xml, "B", "at.dasz.DocumentManagement");
            if (modules.Contains("*") || modules.Contains("at.dasz.DocumentManagement")) XmlStreamer.ToStream(this.Proxy.B_pos, xml, "B_pos", "at.dasz.DocumentManagement");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "at.dasz.DocumentManagement|ExportGuid":
                this.Proxy.ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "at.dasz.DocumentManagement|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "at.dasz.DocumentManagement|A_pos":
                this.Proxy.A_pos = XmlStreamer.ReadNullableInt32(xml);
                break;
            case "at.dasz.DocumentManagement|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "at.dasz.DocumentManagement|B_pos":
                this.Proxy.B_pos = XmlStreamer.ReadNullableInt32(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Document_has_Revisions_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Document_has_Revisions_RelationEntryNHibernateImpl)obj;
            var me = (Document_has_Revisions_RelationEntryNHibernateImpl)this;

            me._fk_A = other._fk_A;
            me.AIndex = other.AIndex;
            me._fk_B = other._fk_B;
            me.BIndex = other.BIndex;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                this.A = ((at.dasz.DocumentManagement.FileNHibernateImpl)OurContext.FindPersistenceObject<at.dasz.DocumentManagement.File>(_fk_guid_A.Value));
            else
            if (_fk_A.HasValue)
                this.A = ((at.dasz.DocumentManagement.FileNHibernateImpl)OurContext.FindPersistenceObject<at.dasz.DocumentManagement.File>(_fk_A.Value));
            else
                this.A = null;

            if (_fk_guid_B.HasValue)
                this.B = ((Zetbox.App.Base.BlobNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Blob>(_fk_guid_B.Value));
            else
            if (_fk_B.HasValue)
                this.B = ((Zetbox.App.Base.BlobNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Blob>(_fk_B.Value));
            else
                this.B = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }

        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow A
            if (this.A != null && this.A.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.A);
                ((NHibernatePersistenceObject)this.A).ChildrenToDelete.Add(this);
            }

            // Follow B
            if (this.B != null && this.B.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.B);
                ((NHibernatePersistenceObject)this.B).ChildrenToDelete.Add(this);
            }

            // remove from collections manually to notify NHibernate if necessary
            if (this.A != null && this.A.Revisions.Contains(this.B)) this.A.Revisions.Remove(this.B);

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.A = null;
            this.B = null;
        }

        public class Document_has_Revisions_RelationEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public Document_has_Revisions_RelationEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(Document_has_Revisions_RelationEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(Document_has_Revisions_RelationEntryProxy); } }

            public virtual at.dasz.DocumentManagement.FileNHibernateImpl.FileProxy A { get; set; }

            public virtual Zetbox.App.Base.BlobNHibernateImpl.BlobProxy B { get; set; }

            public virtual int? A_pos { get; set; }

            public virtual int? B_pos { get; set; }

            public virtual Guid ExportGuid { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.Base
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("Identities_memberOf_Groups_RelationEntryNHibernateImpl")]
    public class Identities_memberOf_Groups_RelationEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.RelationEntryNHibernateImpl<Zetbox.App.Base.Identity, Zetbox.App.Base.IdentityNHibernateImpl, Zetbox.App.Base.Group, Zetbox.App.Base.GroupNHibernateImpl>, Identities_memberOf_Groups_RelationEntry
    {
        public Identities_memberOf_Groups_RelationEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public Identities_memberOf_Groups_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new Identities_memberOf_Groups_RelationEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public Identities_memberOf_Groups_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, Identities_memberOf_Groups_RelationEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly Identities_memberOf_Groups_RelationEntryProxy Proxy;
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("3efb7ae8-ba6b-40e3-9482-b45d1c101743");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Base.Identity)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Group)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=this.Proxy.A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Base.Identity; moduleNamespace=Zetbox.App.Base;
        // will get inverse collection for notifications for Groups
        // PositionStorage=none;
        // Target not exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.Identity A
        {
            get
            {
                Zetbox.App.Base.IdentityNHibernateImpl __value = (Zetbox.App.Base.IdentityNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.A == null)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Base.IdentityNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);
                var __newValue = (Zetbox.App.Base.IdentityNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("Groups", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("Groups", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.A = null;
                }
                else
                {
                    this.Proxy.A = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.Groups as IRelationListSync<Zetbox.App.Base.Identities_memberOf_Groups_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.Groups as IRelationListSync<Zetbox.App.Base.Identities_memberOf_Groups_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for A's id, used on dehydration only</summary>
        private int? _fk_A = null;

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return A != null ? A.ID : (int?)null; }
			set { _fk_A = value; }
		}


    public Zetbox.API.Async.ZbTask TriggerFetchAAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Identity>(this.A);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=this.Proxy.B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Group; moduleNamespace=Zetbox.App.Base;
        // will get inverse collection for notifications for Member
        // PositionStorage=none;
        // Target not exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.Group B
        {
            get
            {
                Zetbox.App.Base.GroupNHibernateImpl __value = (Zetbox.App.Base.GroupNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.B == null)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Base.GroupNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);
                var __newValue = (Zetbox.App.Base.GroupNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("Member", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("Member", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.B = null;
                }
                else
                {
                    this.Proxy.B = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.Member as IRelationListSync<Zetbox.App.Base.Identities_memberOf_Groups_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.Member as IRelationListSync<Zetbox.App.Base.Identities_memberOf_Groups_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for B's id, used on dehydration only</summary>
        private int? _fk_B = null;

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return B != null ? B.ID : (int?)null; }
			set { _fk_B = value; }
		}


    public Zetbox.API.Async.ZbTask TriggerFetchBAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Group>(this.B);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.A != null ? OurContext.GetIdFromProxy(this.Proxy.A) : (int?)null);
            binStream.Write(this.Proxy.B != null ? OurContext.GetIdFromProxy(this.Proxy.B) : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            binStream.Read(out this._fk_A);
            binStream.Read(out this._fk_B);
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Identities_memberOf_Groups_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Identities_memberOf_Groups_RelationEntryNHibernateImpl)obj;
            var me = (Identities_memberOf_Groups_RelationEntryNHibernateImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_A.HasValue)
                this.A = ((Zetbox.App.Base.IdentityNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Identity>(_fk_A.Value));
            else
                this.A = null;

            if (_fk_B.HasValue)
                this.B = ((Zetbox.App.Base.GroupNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Group>(_fk_B.Value));
            else
                this.B = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }

        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow A
            if (this.A != null && this.A.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.A);
                ((NHibernatePersistenceObject)this.A).ChildrenToDelete.Add(this);
            }

            // Follow B
            if (this.B != null && this.B.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.B);
                ((NHibernatePersistenceObject)this.B).ChildrenToDelete.Add(this);
            }

            // remove from collections manually to notify NHibernate if necessary
            if (this.A != null && this.A.Groups.Contains(this.B)) this.A.Groups.Remove(this.B);
            else
            // The other direction is handled by the infrastructure (but A might be null)
            if (this.B != null && this.B.Member.Contains(this.A)) this.B.Member.Remove(this.A);

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.A = null;
            this.B = null;
        }

        public class Identities_memberOf_Groups_RelationEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public Identities_memberOf_Groups_RelationEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(Identities_memberOf_Groups_RelationEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(Identities_memberOf_Groups_RelationEntryProxy); } }

            public virtual Zetbox.App.Base.IdentityNHibernateImpl.IdentityProxy A { get; set; }

            public virtual Zetbox.App.Base.GroupNHibernateImpl.GroupProxy B { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.Test
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("MB_Many_Role_has_TCO_ManyList_Role_RelationEntryNHibernateImpl")]
    public class MB_Many_Role_has_TCO_ManyList_Role_RelationEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.RelationEntryNHibernateImpl<Zetbox.App.Test.Muhblah, Zetbox.App.Test.MuhblahNHibernateImpl, Zetbox.App.Test.TestCustomObject, Zetbox.App.Test.TestCustomObjectNHibernateImpl>, MB_Many_Role_has_TCO_ManyList_Role_RelationEntry
    {
        public MB_Many_Role_has_TCO_ManyList_Role_RelationEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public MB_Many_Role_has_TCO_ManyList_Role_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new MB_Many_Role_has_TCO_ManyList_Role_RelationEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public MB_Many_Role_has_TCO_ManyList_Role_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, MB_Many_Role_has_TCO_ManyList_Role_RelationEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly MB_Many_Role_has_TCO_ManyList_Role_RelationEntryProxy Proxy;
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("d1e0da3e-ce64-4587-b62d-70c0f4371d97");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Test.Muhblah)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Test.TestCustomObject)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=this.Proxy.A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Test.Muhblah; moduleNamespace=Zetbox.App.Test;
        // will get inverse collection for notifications for TestCustomObjects_ManyList_Nav
        // PositionStorage=none;
        // Target not exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Test.Muhblah A
        {
            get
            {
                Zetbox.App.Test.MuhblahNHibernateImpl __value = (Zetbox.App.Test.MuhblahNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.A == null)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Test.MuhblahNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);
                var __newValue = (Zetbox.App.Test.MuhblahNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("TestCustomObjects_ManyList_Nav", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("TestCustomObjects_ManyList_Nav", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.A = null;
                }
                else
                {
                    this.Proxy.A = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.TestCustomObjects_ManyList_Nav as IRelationListSync<Zetbox.App.Test.MB_Many_Role_has_TCO_ManyList_Role_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.TestCustomObjects_ManyList_Nav as IRelationListSync<Zetbox.App.Test.MB_Many_Role_has_TCO_ManyList_Role_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for A's id, used on dehydration only</summary>
        private int? _fk_A = null;

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return A != null ? A.ID : (int?)null; }
			set { _fk_A = value; }
		}


    public Zetbox.API.Async.ZbTask TriggerFetchAAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Test.Muhblah>(this.A);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=this.Proxy.B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Test.TestCustomObject; moduleNamespace=Zetbox.App.Test;
        // will get inverse collection for notifications for MuhBlah_ManyList_Nav
        // PositionStorage=none;
        // Target not exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Test.TestCustomObject B
        {
            get
            {
                Zetbox.App.Test.TestCustomObjectNHibernateImpl __value = (Zetbox.App.Test.TestCustomObjectNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.B == null)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Test.TestCustomObjectNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);
                var __newValue = (Zetbox.App.Test.TestCustomObjectNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("MuhBlah_ManyList_Nav", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("MuhBlah_ManyList_Nav", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.B = null;
                }
                else
                {
                    this.Proxy.B = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.MuhBlah_ManyList_Nav as IRelationListSync<Zetbox.App.Test.MB_Many_Role_has_TCO_ManyList_Role_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.MuhBlah_ManyList_Nav as IRelationListSync<Zetbox.App.Test.MB_Many_Role_has_TCO_ManyList_Role_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for B's id, used on dehydration only</summary>
        private int? _fk_B = null;

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return B != null ? B.ID : (int?)null; }
			set { _fk_B = value; }
		}


    public Zetbox.API.Async.ZbTask TriggerFetchBAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Test.TestCustomObject>(this.B);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.A != null ? OurContext.GetIdFromProxy(this.Proxy.A) : (int?)null);
            binStream.Write(this.Proxy.B != null ? OurContext.GetIdFromProxy(this.Proxy.B) : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            binStream.Read(out this._fk_A);
            binStream.Read(out this._fk_B);
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(MB_Many_Role_has_TCO_ManyList_Role_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (MB_Many_Role_has_TCO_ManyList_Role_RelationEntryNHibernateImpl)obj;
            var me = (MB_Many_Role_has_TCO_ManyList_Role_RelationEntryNHibernateImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_A.HasValue)
                this.A = ((Zetbox.App.Test.MuhblahNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Test.Muhblah>(_fk_A.Value));
            else
                this.A = null;

            if (_fk_B.HasValue)
                this.B = ((Zetbox.App.Test.TestCustomObjectNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Test.TestCustomObject>(_fk_B.Value));
            else
                this.B = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }

        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow A
            if (this.A != null && this.A.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.A);
                ((NHibernatePersistenceObject)this.A).ChildrenToDelete.Add(this);
            }

            // Follow B
            if (this.B != null && this.B.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.B);
                ((NHibernatePersistenceObject)this.B).ChildrenToDelete.Add(this);
            }

            // remove from collections manually to notify NHibernate if necessary
            if (this.A != null && this.A.TestCustomObjects_ManyList_Nav.Contains(this.B)) this.A.TestCustomObjects_ManyList_Nav.Remove(this.B);
            else
            // The other direction is handled by the infrastructure (but A might be null)
            if (this.B != null && this.B.MuhBlah_ManyList_Nav.Contains(this.A)) this.B.MuhBlah_ManyList_Nav.Remove(this.A);

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.A = null;
            this.B = null;
        }

        public class MB_Many_Role_has_TCO_ManyList_Role_RelationEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public MB_Many_Role_has_TCO_ManyList_Role_RelationEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(MB_Many_Role_has_TCO_ManyList_Role_RelationEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(MB_Many_Role_has_TCO_ManyList_Role_RelationEntryProxy); } }

            public virtual Zetbox.App.Test.MuhblahNHibernateImpl.MuhblahProxy A { get; set; }

            public virtual Zetbox.App.Test.TestCustomObjectNHibernateImpl.TestCustomObjectProxy B { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.GUI
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("NavigationScreen_accessed_by_Groups_RelationEntryNHibernateImpl")]
    public class NavigationScreen_accessed_by_Groups_RelationEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.RelationEntryNHibernateImpl<Zetbox.App.GUI.NavigationEntry, Zetbox.App.GUI.NavigationEntryNHibernateImpl, Zetbox.App.Base.Group, Zetbox.App.Base.GroupNHibernateImpl>, NavigationScreen_accessed_by_Groups_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        public NavigationScreen_accessed_by_Groups_RelationEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public NavigationScreen_accessed_by_Groups_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new NavigationScreen_accessed_by_Groups_RelationEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public NavigationScreen_accessed_by_Groups_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, NavigationScreen_accessed_by_Groups_RelationEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly NavigationScreen_accessed_by_Groups_RelationEntryProxy Proxy;

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.ExportGuid;
                if (this.Proxy.ExportGuid == Guid.Empty) {
                    __result = this.Proxy.ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.ExportGuid != value)
                {
                    var __oldValue = Proxy.ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    Proxy.ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("b88c12ac-eabe-4aee-913e-5edd9d2a193a");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.GUI.NavigationEntry)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Group)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=this.Proxy.A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.GUI.NavigationEntry; moduleNamespace=Zetbox.App.GUI;
        // will get inverse collection for notifications for Groups
        // PositionStorage=none;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.GUI.NavigationEntry A
        {
            get
            {
                Zetbox.App.GUI.NavigationEntryNHibernateImpl __value = (Zetbox.App.GUI.NavigationEntryNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.A == null)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.GUI.NavigationEntryNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);
                var __newValue = (Zetbox.App.GUI.NavigationEntryNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("Groups", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("Groups", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.A = null;
                }
                else
                {
                    this.Proxy.A = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.Groups as IRelationListSync<Zetbox.App.GUI.NavigationScreen_accessed_by_Groups_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.Groups as IRelationListSync<Zetbox.App.GUI.NavigationScreen_accessed_by_Groups_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for A's id, used on dehydration only</summary>
        private int? _fk_A = null;

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return A != null ? A.ID : (int?)null; }
			set { _fk_A = value; }
		}

        /// <summary>Backing store for A's guid, used on import only</summary>
        private Guid? _fk_guid_A = null;

    public Zetbox.API.Async.ZbTask TriggerFetchAAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.GUI.NavigationEntry>(this.A);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=this.Proxy.B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Group; moduleNamespace=Zetbox.App.GUI;
        // no inverse navigator handling
        // PositionStorage=none;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.Group B
        {
            get
            {
                Zetbox.App.Base.GroupNHibernateImpl __value = (Zetbox.App.Base.GroupNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.B == null)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Base.GroupNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);
                var __newValue = (Zetbox.App.Base.GroupNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.B = null;
                }
                else
                {
                    this.Proxy.B = __newValue.Proxy;
                }

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for B's id, used on dehydration only</summary>
        private int? _fk_B = null;

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return B != null ? B.ID : (int?)null; }
			set { _fk_B = value; }
		}

        /// <summary>Backing store for B's guid, used on import only</summary>
        private Guid? _fk_guid_B = null;

    public Zetbox.API.Async.ZbTask TriggerFetchBAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Group>(this.B);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.ExportGuid);
            binStream.Write(this.Proxy.A != null ? OurContext.GetIdFromProxy(this.Proxy.A) : (int?)null);
            binStream.Write(this.Proxy.B != null ? OurContext.GetIdFromProxy(this.Proxy.B) : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this.Proxy.ExportGuid = binStream.ReadGuid();
            binStream.Read(out this._fk_A);
            binStream.Read(out this._fk_B);
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", this.Proxy.ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.GUI")) XmlStreamer.ToStream(this.Proxy.A != null ? this.Proxy.A.ExportGuid : (Guid?)null, xml, "A", "Zetbox.App.GUI");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.GUI")) XmlStreamer.ToStream(this.Proxy.B != null ? this.Proxy.B.ExportGuid : (Guid?)null, xml, "B", "Zetbox.App.GUI");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "Zetbox.App.GUI|ExportGuid":
                this.Proxy.ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "Zetbox.App.GUI|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.GUI|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(NavigationScreen_accessed_by_Groups_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (NavigationScreen_accessed_by_Groups_RelationEntryNHibernateImpl)obj;
            var me = (NavigationScreen_accessed_by_Groups_RelationEntryNHibernateImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                this.A = ((Zetbox.App.GUI.NavigationEntryNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.GUI.NavigationEntry>(_fk_guid_A.Value));
            else
            if (_fk_A.HasValue)
                this.A = ((Zetbox.App.GUI.NavigationEntryNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.GUI.NavigationEntry>(_fk_A.Value));
            else
                this.A = null;

            if (_fk_guid_B.HasValue)
                this.B = ((Zetbox.App.Base.GroupNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Group>(_fk_guid_B.Value));
            else
            if (_fk_B.HasValue)
                this.B = ((Zetbox.App.Base.GroupNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Group>(_fk_B.Value));
            else
                this.B = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }

        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow A
            if (this.A != null && this.A.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.A);
                ((NHibernatePersistenceObject)this.A).ChildrenToDelete.Add(this);
            }

            // Follow B
            if (this.B != null && this.B.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.B);
                ((NHibernatePersistenceObject)this.B).ChildrenToDelete.Add(this);
            }

            // remove from collections manually to notify NHibernate if necessary
            if (this.A != null && this.A.Groups.Contains(this.B)) this.A.Groups.Remove(this.B);

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.A = null;
            this.B = null;
        }

        public class NavigationScreen_accessed_by_Groups_RelationEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public NavigationScreen_accessed_by_Groups_RelationEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(NavigationScreen_accessed_by_Groups_RelationEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(NavigationScreen_accessed_by_Groups_RelationEntryProxy); } }

            public virtual Zetbox.App.GUI.NavigationEntryNHibernateImpl.NavigationEntryProxy A { get; set; }

            public virtual Zetbox.App.Base.GroupNHibernateImpl.GroupProxy B { get; set; }

            public virtual Guid ExportGuid { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.GUI
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("ObjRefProp_shows_Methods_RelationEntryNHibernateImpl")]
    public class ObjRefProp_shows_Methods_RelationEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.RelationEntryNHibernateImpl<Zetbox.App.Base.ObjectReferenceProperty, Zetbox.App.Base.ObjectReferencePropertyNHibernateImpl, Zetbox.App.Base.Method, Zetbox.App.Base.MethodNHibernateImpl>, ObjRefProp_shows_Methods_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        public ObjRefProp_shows_Methods_RelationEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public ObjRefProp_shows_Methods_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new ObjRefProp_shows_Methods_RelationEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public ObjRefProp_shows_Methods_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, ObjRefProp_shows_Methods_RelationEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly ObjRefProp_shows_Methods_RelationEntryProxy Proxy;

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.ExportGuid;
                if (this.Proxy.ExportGuid == Guid.Empty) {
                    __result = this.Proxy.ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.ExportGuid != value)
                {
                    var __oldValue = Proxy.ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    Proxy.ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("02b3e9d5-fc2e-4ffe-8867-0977b88437cc");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Base.ObjectReferenceProperty)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Method)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=this.Proxy.A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Base.ObjectReferenceProperty; moduleNamespace=Zetbox.App.GUI;
        // will get inverse collection for notifications for Methods
        // PositionStorage=none;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.ObjectReferenceProperty A
        {
            get
            {
                Zetbox.App.Base.ObjectReferencePropertyNHibernateImpl __value = (Zetbox.App.Base.ObjectReferencePropertyNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.A == null)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Base.ObjectReferencePropertyNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);
                var __newValue = (Zetbox.App.Base.ObjectReferencePropertyNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("Methods", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("Methods", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.A = null;
                }
                else
                {
                    this.Proxy.A = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.Methods as IRelationListSync<Zetbox.App.GUI.ObjRefProp_shows_Methods_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.Methods as IRelationListSync<Zetbox.App.GUI.ObjRefProp_shows_Methods_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for A's id, used on dehydration only</summary>
        private int? _fk_A = null;

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return A != null ? A.ID : (int?)null; }
			set { _fk_A = value; }
		}

        /// <summary>Backing store for A's guid, used on import only</summary>
        private Guid? _fk_guid_A = null;

    public Zetbox.API.Async.ZbTask TriggerFetchAAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Base.ObjectReferenceProperty>(this.A);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=this.Proxy.B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Method; moduleNamespace=Zetbox.App.GUI;
        // will get inverse collection for notifications for ShowByProperties
        // PositionStorage=none;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.Method B
        {
            get
            {
                Zetbox.App.Base.MethodNHibernateImpl __value = (Zetbox.App.Base.MethodNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.B == null)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Base.MethodNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);
                var __newValue = (Zetbox.App.Base.MethodNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("ShowByProperties", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("ShowByProperties", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.B = null;
                }
                else
                {
                    this.Proxy.B = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.ShowByProperties as IRelationListSync<Zetbox.App.GUI.ObjRefProp_shows_Methods_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.ShowByProperties as IRelationListSync<Zetbox.App.GUI.ObjRefProp_shows_Methods_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for B's id, used on dehydration only</summary>
        private int? _fk_B = null;

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return B != null ? B.ID : (int?)null; }
			set { _fk_B = value; }
		}

        /// <summary>Backing store for B's guid, used on import only</summary>
        private Guid? _fk_guid_B = null;

    public Zetbox.API.Async.ZbTask TriggerFetchBAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Method>(this.B);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.ExportGuid);
            binStream.Write(this.Proxy.A != null ? OurContext.GetIdFromProxy(this.Proxy.A) : (int?)null);
            binStream.Write(this.Proxy.B != null ? OurContext.GetIdFromProxy(this.Proxy.B) : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this.Proxy.ExportGuid = binStream.ReadGuid();
            binStream.Read(out this._fk_A);
            binStream.Read(out this._fk_B);
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", this.Proxy.ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.GUI")) XmlStreamer.ToStream(this.Proxy.A != null ? this.Proxy.A.ExportGuid : (Guid?)null, xml, "A", "Zetbox.App.GUI");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.GUI")) XmlStreamer.ToStream(this.Proxy.B != null ? this.Proxy.B.ExportGuid : (Guid?)null, xml, "B", "Zetbox.App.GUI");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "Zetbox.App.GUI|ExportGuid":
                this.Proxy.ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "Zetbox.App.GUI|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.GUI|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(ObjRefProp_shows_Methods_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (ObjRefProp_shows_Methods_RelationEntryNHibernateImpl)obj;
            var me = (ObjRefProp_shows_Methods_RelationEntryNHibernateImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                this.A = ((Zetbox.App.Base.ObjectReferencePropertyNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.ObjectReferenceProperty>(_fk_guid_A.Value));
            else
            if (_fk_A.HasValue)
                this.A = ((Zetbox.App.Base.ObjectReferencePropertyNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.ObjectReferenceProperty>(_fk_A.Value));
            else
                this.A = null;

            if (_fk_guid_B.HasValue)
                this.B = ((Zetbox.App.Base.MethodNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Method>(_fk_guid_B.Value));
            else
            if (_fk_B.HasValue)
                this.B = ((Zetbox.App.Base.MethodNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Method>(_fk_B.Value));
            else
                this.B = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }

        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow A
            if (this.A != null && this.A.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.A);
                ((NHibernatePersistenceObject)this.A).ChildrenToDelete.Add(this);
            }

            // Follow B
            if (this.B != null && this.B.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.B);
                ((NHibernatePersistenceObject)this.B).ChildrenToDelete.Add(this);
            }

            // remove from collections manually to notify NHibernate if necessary
            if (this.A != null && this.A.Methods.Contains(this.B)) this.A.Methods.Remove(this.B);
            else
            // The other direction is handled by the infrastructure (but A might be null)
            if (this.B != null && this.B.ShowByProperties.Contains(this.A)) this.B.ShowByProperties.Remove(this.A);

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.A = null;
            this.B = null;
        }

        public class ObjRefProp_shows_Methods_RelationEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public ObjRefProp_shows_Methods_RelationEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(ObjRefProp_shows_Methods_RelationEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(ObjRefProp_shows_Methods_RelationEntryProxy); } }

            public virtual Zetbox.App.Base.ObjectReferencePropertyNHibernateImpl.ObjectReferencePropertyProxy A { get; set; }

            public virtual Zetbox.App.Base.MethodNHibernateImpl.MethodProxy B { get; set; }

            public virtual Guid ExportGuid { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.GUI
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("Presentable_displayedBy_SecondaryControlKinds_RelationEntryNHibernateImpl")]
    public class Presentable_displayedBy_SecondaryControlKinds_RelationEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.RelationEntryNHibernateImpl<Zetbox.App.GUI.ViewModelDescriptor, Zetbox.App.GUI.ViewModelDescriptorNHibernateImpl, Zetbox.App.GUI.ControlKind, Zetbox.App.GUI.ControlKindNHibernateImpl>, Presentable_displayedBy_SecondaryControlKinds_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        public Presentable_displayedBy_SecondaryControlKinds_RelationEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public Presentable_displayedBy_SecondaryControlKinds_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new Presentable_displayedBy_SecondaryControlKinds_RelationEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public Presentable_displayedBy_SecondaryControlKinds_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, Presentable_displayedBy_SecondaryControlKinds_RelationEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly Presentable_displayedBy_SecondaryControlKinds_RelationEntryProxy Proxy;

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.ExportGuid;
                if (this.Proxy.ExportGuid == Guid.Empty) {
                    __result = this.Proxy.ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.ExportGuid != value)
                {
                    var __oldValue = Proxy.ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    Proxy.ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("5404456a-4527-4e40-a660-b4a5e96e4a47");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.GUI.ViewModelDescriptor)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.GUI.ControlKind)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=this.Proxy.A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.GUI.ViewModelDescriptor; moduleNamespace=Zetbox.App.GUI;
        // will get inverse collection for notifications for SecondaryControlKinds
        // PositionStorage=none;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.GUI.ViewModelDescriptor A
        {
            get
            {
                Zetbox.App.GUI.ViewModelDescriptorNHibernateImpl __value = (Zetbox.App.GUI.ViewModelDescriptorNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.A == null)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.GUI.ViewModelDescriptorNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);
                var __newValue = (Zetbox.App.GUI.ViewModelDescriptorNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("SecondaryControlKinds", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("SecondaryControlKinds", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.A = null;
                }
                else
                {
                    this.Proxy.A = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.SecondaryControlKinds as IRelationListSync<Zetbox.App.GUI.Presentable_displayedBy_SecondaryControlKinds_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.SecondaryControlKinds as IRelationListSync<Zetbox.App.GUI.Presentable_displayedBy_SecondaryControlKinds_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for A's id, used on dehydration only</summary>
        private int? _fk_A = null;

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return A != null ? A.ID : (int?)null; }
			set { _fk_A = value; }
		}

        /// <summary>Backing store for A's guid, used on import only</summary>
        private Guid? _fk_guid_A = null;

    public Zetbox.API.Async.ZbTask TriggerFetchAAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.GUI.ViewModelDescriptor>(this.A);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=this.Proxy.B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.GUI.ControlKind; moduleNamespace=Zetbox.App.GUI;
        // no inverse navigator handling
        // PositionStorage=none;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.GUI.ControlKind B
        {
            get
            {
                Zetbox.App.GUI.ControlKindNHibernateImpl __value = (Zetbox.App.GUI.ControlKindNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.B == null)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.GUI.ControlKindNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);
                var __newValue = (Zetbox.App.GUI.ControlKindNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.B = null;
                }
                else
                {
                    this.Proxy.B = __newValue.Proxy;
                }

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for B's id, used on dehydration only</summary>
        private int? _fk_B = null;

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return B != null ? B.ID : (int?)null; }
			set { _fk_B = value; }
		}

        /// <summary>Backing store for B's guid, used on import only</summary>
        private Guid? _fk_guid_B = null;

    public Zetbox.API.Async.ZbTask TriggerFetchBAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.GUI.ControlKind>(this.B);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.ExportGuid);
            binStream.Write(this.Proxy.A != null ? OurContext.GetIdFromProxy(this.Proxy.A) : (int?)null);
            binStream.Write(this.Proxy.B != null ? OurContext.GetIdFromProxy(this.Proxy.B) : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this.Proxy.ExportGuid = binStream.ReadGuid();
            binStream.Read(out this._fk_A);
            binStream.Read(out this._fk_B);
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", this.Proxy.ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.GUI")) XmlStreamer.ToStream(this.Proxy.A != null ? this.Proxy.A.ExportGuid : (Guid?)null, xml, "A", "Zetbox.App.GUI");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.GUI")) XmlStreamer.ToStream(this.Proxy.B != null ? this.Proxy.B.ExportGuid : (Guid?)null, xml, "B", "Zetbox.App.GUI");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "Zetbox.App.GUI|ExportGuid":
                this.Proxy.ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "Zetbox.App.GUI|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.GUI|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Presentable_displayedBy_SecondaryControlKinds_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Presentable_displayedBy_SecondaryControlKinds_RelationEntryNHibernateImpl)obj;
            var me = (Presentable_displayedBy_SecondaryControlKinds_RelationEntryNHibernateImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                this.A = ((Zetbox.App.GUI.ViewModelDescriptorNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.GUI.ViewModelDescriptor>(_fk_guid_A.Value));
            else
            if (_fk_A.HasValue)
                this.A = ((Zetbox.App.GUI.ViewModelDescriptorNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.GUI.ViewModelDescriptor>(_fk_A.Value));
            else
                this.A = null;

            if (_fk_guid_B.HasValue)
                this.B = ((Zetbox.App.GUI.ControlKindNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.GUI.ControlKind>(_fk_guid_B.Value));
            else
            if (_fk_B.HasValue)
                this.B = ((Zetbox.App.GUI.ControlKindNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.GUI.ControlKind>(_fk_B.Value));
            else
                this.B = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }

        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow A
            if (this.A != null && this.A.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.A);
                ((NHibernatePersistenceObject)this.A).ChildrenToDelete.Add(this);
            }

            // Follow B
            if (this.B != null && this.B.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.B);
                ((NHibernatePersistenceObject)this.B).ChildrenToDelete.Add(this);
            }

            // remove from collections manually to notify NHibernate if necessary
            if (this.A != null && this.A.SecondaryControlKinds.Contains(this.B)) this.A.SecondaryControlKinds.Remove(this.B);

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.A = null;
            this.B = null;
        }

        public class Presentable_displayedBy_SecondaryControlKinds_RelationEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public Presentable_displayedBy_SecondaryControlKinds_RelationEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(Presentable_displayedBy_SecondaryControlKinds_RelationEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(Presentable_displayedBy_SecondaryControlKinds_RelationEntryProxy); } }

            public virtual Zetbox.App.GUI.ViewModelDescriptorNHibernateImpl.ViewModelDescriptorProxy A { get; set; }

            public virtual Zetbox.App.GUI.ControlKindNHibernateImpl.ControlKindProxy B { get; set; }

            public virtual Guid ExportGuid { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.Projekte
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("Projekte_haben_Mitarbeiter_RelationEntryNHibernateImpl")]
    public class Projekte_haben_Mitarbeiter_RelationEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.RelationEntryNHibernateImpl<Zetbox.App.Projekte.Projekt, Zetbox.App.Projekte.ProjektNHibernateImpl, Zetbox.App.Projekte.Mitarbeiter, Zetbox.App.Projekte.MitarbeiterNHibernateImpl>, Projekte_haben_Mitarbeiter_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        public Projekte_haben_Mitarbeiter_RelationEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public Projekte_haben_Mitarbeiter_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new Projekte_haben_Mitarbeiter_RelationEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public Projekte_haben_Mitarbeiter_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, Projekte_haben_Mitarbeiter_RelationEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly Projekte_haben_Mitarbeiter_RelationEntryProxy Proxy;

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.ExportGuid;
                if (this.Proxy.ExportGuid == Guid.Empty) {
                    __result = this.Proxy.ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.ExportGuid != value)
                {
                    var __oldValue = Proxy.ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    Proxy.ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("c7b3cf10-cdc8-454c-826c-04a0f7e5ef3e");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Projekte.Projekt)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Projekte.Mitarbeiter)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=this.Proxy.A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Projekte.Projekt; moduleNamespace=Zetbox.App.Projekte;
        // will get inverse collection for notifications for Mitarbeiter
        // PositionStorage=A_pos;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Projekte.Projekt A
        {
            get
            {
                Zetbox.App.Projekte.ProjektNHibernateImpl __value = (Zetbox.App.Projekte.ProjektNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.A == null)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Projekte.ProjektNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);
                var __newValue = (Zetbox.App.Projekte.ProjektNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("Mitarbeiter", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("Mitarbeiter", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.A = null;
                }
                else
                {
                    this.Proxy.A = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.Mitarbeiter as IRelationListSync<Zetbox.App.Projekte.Projekte_haben_Mitarbeiter_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.Mitarbeiter as IRelationListSync<Zetbox.App.Projekte.Projekte_haben_Mitarbeiter_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for A's id, used on dehydration only</summary>
        private int? _fk_A = null;

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return A != null ? A.ID : (int?)null; }
			set { _fk_A = value; }
		}

        /// <summary>Backing store for A's guid, used on import only</summary>
        private Guid? _fk_guid_A = null;

    public Zetbox.API.Async.ZbTask TriggerFetchAAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Projekte.Projekt>(this.A);
    }

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        public virtual int? A_pos
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.A_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.A_pos != value)
                {
                    var __oldValue = Proxy.A_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("A_pos", __oldValue, __newValue);
                    Proxy.A_pos = __newValue;
                    NotifyPropertyChanged("A_pos", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("A_pos");
                }
            }
        }
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=this.Proxy.B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Projekte.Mitarbeiter; moduleNamespace=Zetbox.App.Projekte;
        // will get inverse collection for notifications for Projekte
        // PositionStorage=B_pos;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Projekte.Mitarbeiter B
        {
            get
            {
                Zetbox.App.Projekte.MitarbeiterNHibernateImpl __value = (Zetbox.App.Projekte.MitarbeiterNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.B == null)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Projekte.MitarbeiterNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);
                var __newValue = (Zetbox.App.Projekte.MitarbeiterNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("Projekte", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("Projekte", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.B = null;
                }
                else
                {
                    this.Proxy.B = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.Projekte as IRelationListSync<Zetbox.App.Projekte.Projekte_haben_Mitarbeiter_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.Projekte as IRelationListSync<Zetbox.App.Projekte.Projekte_haben_Mitarbeiter_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for B's id, used on dehydration only</summary>
        private int? _fk_B = null;

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return B != null ? B.ID : (int?)null; }
			set { _fk_B = value; }
		}

        /// <summary>Backing store for B's guid, used on import only</summary>
        private Guid? _fk_guid_B = null;

    public Zetbox.API.Async.ZbTask TriggerFetchBAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Projekte.Mitarbeiter>(this.B);
    }

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        public virtual int? B_pos
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.B_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.B_pos != value)
                {
                    var __oldValue = Proxy.B_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("B_pos", __oldValue, __newValue);
                    Proxy.B_pos = __newValue;
                    NotifyPropertyChanged("B_pos", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("B_pos");
                }
            }
        }
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        /// <summary>
        /// Index into the A-side list of this relation
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public int? AIndex
        {
            get { return this.A_pos; }
            set { this.A_pos = (int?)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        /// <summary>
        /// Index into the B-side list of this relation
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public int? BIndex
        {
            get { return this.B_pos; }
            set { this.B_pos = (int?)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.ExportGuid);
            binStream.Write(this.Proxy.A != null ? OurContext.GetIdFromProxy(this.Proxy.A) : (int?)null);
            binStream.Write(this.Proxy.A_pos);
            binStream.Write(this.Proxy.B != null ? OurContext.GetIdFromProxy(this.Proxy.B) : (int?)null);
            binStream.Write(this.Proxy.B_pos);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this.Proxy.ExportGuid = binStream.ReadGuid();
            binStream.Read(out this._fk_A);
            this.Proxy.A_pos = binStream.ReadNullableInt32();
            binStream.Read(out this._fk_B);
            this.Proxy.B_pos = binStream.ReadNullableInt32();
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", this.Proxy.ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Projekte")) XmlStreamer.ToStream(this.Proxy.A != null ? this.Proxy.A.ExportGuid : (Guid?)null, xml, "A", "Zetbox.App.Projekte");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Projekte")) XmlStreamer.ToStream(this.Proxy.A_pos, xml, "A_pos", "Zetbox.App.Projekte");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Projekte")) XmlStreamer.ToStream(this.Proxy.B != null ? this.Proxy.B.ExportGuid : (Guid?)null, xml, "B", "Zetbox.App.Projekte");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Projekte")) XmlStreamer.ToStream(this.Proxy.B_pos, xml, "B_pos", "Zetbox.App.Projekte");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "Zetbox.App.Projekte|ExportGuid":
                this.Proxy.ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "Zetbox.App.Projekte|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.Projekte|A_pos":
                this.Proxy.A_pos = XmlStreamer.ReadNullableInt32(xml);
                break;
            case "Zetbox.App.Projekte|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.Projekte|B_pos":
                this.Proxy.B_pos = XmlStreamer.ReadNullableInt32(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Projekte_haben_Mitarbeiter_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Projekte_haben_Mitarbeiter_RelationEntryNHibernateImpl)obj;
            var me = (Projekte_haben_Mitarbeiter_RelationEntryNHibernateImpl)this;

            me._fk_A = other._fk_A;
            me.AIndex = other.AIndex;
            me._fk_B = other._fk_B;
            me.BIndex = other.BIndex;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                this.A = ((Zetbox.App.Projekte.ProjektNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Projekte.Projekt>(_fk_guid_A.Value));
            else
            if (_fk_A.HasValue)
                this.A = ((Zetbox.App.Projekte.ProjektNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Projekte.Projekt>(_fk_A.Value));
            else
                this.A = null;

            if (_fk_guid_B.HasValue)
                this.B = ((Zetbox.App.Projekte.MitarbeiterNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Projekte.Mitarbeiter>(_fk_guid_B.Value));
            else
            if (_fk_B.HasValue)
                this.B = ((Zetbox.App.Projekte.MitarbeiterNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Projekte.Mitarbeiter>(_fk_B.Value));
            else
                this.B = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }

        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow A
            if (this.A != null && this.A.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.A);
                ((NHibernatePersistenceObject)this.A).ChildrenToDelete.Add(this);
            }

            // Follow B
            if (this.B != null && this.B.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.B);
                ((NHibernatePersistenceObject)this.B).ChildrenToDelete.Add(this);
            }

            // remove from collections manually to notify NHibernate if necessary
            if (this.A != null && this.A.Mitarbeiter.Contains(this.B)) this.A.Mitarbeiter.Remove(this.B);
            else
            // The other direction is handled by the infrastructure (but A might be null)
            if (this.B != null && this.B.Projekte.Contains(this.A)) this.B.Projekte.Remove(this.A);

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.A = null;
            this.B = null;
        }

        public class Projekte_haben_Mitarbeiter_RelationEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public Projekte_haben_Mitarbeiter_RelationEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(Projekte_haben_Mitarbeiter_RelationEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(Projekte_haben_Mitarbeiter_RelationEntryProxy); } }

            public virtual Zetbox.App.Projekte.ProjektNHibernateImpl.ProjektProxy A { get; set; }

            public virtual Zetbox.App.Projekte.MitarbeiterNHibernateImpl.MitarbeiterProxy B { get; set; }

            public virtual int? A_pos { get; set; }

            public virtual int? B_pos { get; set; }

            public virtual Guid ExportGuid { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.Base
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("RoleMembership_resolves_Relations_RelationEntryNHibernateImpl")]
    public class RoleMembership_resolves_Relations_RelationEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.RelationEntryNHibernateImpl<Zetbox.App.Base.RoleMembership, Zetbox.App.Base.RoleMembershipNHibernateImpl, Zetbox.App.Base.Relation, Zetbox.App.Base.RelationNHibernateImpl>, RoleMembership_resolves_Relations_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        public RoleMembership_resolves_Relations_RelationEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public RoleMembership_resolves_Relations_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new RoleMembership_resolves_Relations_RelationEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public RoleMembership_resolves_Relations_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, RoleMembership_resolves_Relations_RelationEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly RoleMembership_resolves_Relations_RelationEntryProxy Proxy;

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.ExportGuid;
                if (this.Proxy.ExportGuid == Guid.Empty) {
                    __result = this.Proxy.ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.ExportGuid != value)
                {
                    var __oldValue = Proxy.ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    Proxy.ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("f74d425f-e733-4cba-baca-f4a05fbc0a80");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Base.RoleMembership)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Relation)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=this.Proxy.A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Base.RoleMembership; moduleNamespace=Zetbox.App.Base;
        // will get inverse collection for notifications for Relations
        // PositionStorage=A_pos;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.RoleMembership A
        {
            get
            {
                Zetbox.App.Base.RoleMembershipNHibernateImpl __value = (Zetbox.App.Base.RoleMembershipNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.A == null)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Base.RoleMembershipNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);
                var __newValue = (Zetbox.App.Base.RoleMembershipNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("Relations", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("Relations", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.A = null;
                }
                else
                {
                    this.Proxy.A = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.Relations as IRelationListSync<Zetbox.App.Base.RoleMembership_resolves_Relations_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.Relations as IRelationListSync<Zetbox.App.Base.RoleMembership_resolves_Relations_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for A's id, used on dehydration only</summary>
        private int? _fk_A = null;

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return A != null ? A.ID : (int?)null; }
			set { _fk_A = value; }
		}

        /// <summary>Backing store for A's guid, used on import only</summary>
        private Guid? _fk_guid_A = null;

    public Zetbox.API.Async.ZbTask TriggerFetchAAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Base.RoleMembership>(this.A);
    }

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        public virtual int? A_pos
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.A_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.A_pos != value)
                {
                    var __oldValue = Proxy.A_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("A_pos", __oldValue, __newValue);
                    Proxy.A_pos = __newValue;
                    NotifyPropertyChanged("A_pos", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("A_pos");
                }
            }
        }
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=this.Proxy.B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Relation; moduleNamespace=Zetbox.App.Base;
        // no inverse navigator handling
        // PositionStorage=B_pos;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.Relation B
        {
            get
            {
                Zetbox.App.Base.RelationNHibernateImpl __value = (Zetbox.App.Base.RelationNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.B == null)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Base.RelationNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);
                var __newValue = (Zetbox.App.Base.RelationNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.B = null;
                }
                else
                {
                    this.Proxy.B = __newValue.Proxy;
                }

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for B's id, used on dehydration only</summary>
        private int? _fk_B = null;

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return B != null ? B.ID : (int?)null; }
			set { _fk_B = value; }
		}

        /// <summary>Backing store for B's guid, used on import only</summary>
        private Guid? _fk_guid_B = null;

    public Zetbox.API.Async.ZbTask TriggerFetchBAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Relation>(this.B);
    }

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        public virtual int? B_pos
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.B_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.B_pos != value)
                {
                    var __oldValue = Proxy.B_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("B_pos", __oldValue, __newValue);
                    Proxy.B_pos = __newValue;
                    NotifyPropertyChanged("B_pos", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("B_pos");
                }
            }
        }
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        /// <summary>
        /// Index into the A-side list of this relation
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public int? AIndex
        {
            get { return this.A_pos; }
            set { this.A_pos = (int?)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        /// <summary>
        /// Index into the B-side list of this relation
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public int? BIndex
        {
            get { return this.B_pos; }
            set { this.B_pos = (int?)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.ExportGuid);
            binStream.Write(this.Proxy.A != null ? OurContext.GetIdFromProxy(this.Proxy.A) : (int?)null);
            binStream.Write(this.Proxy.A_pos);
            binStream.Write(this.Proxy.B != null ? OurContext.GetIdFromProxy(this.Proxy.B) : (int?)null);
            binStream.Write(this.Proxy.B_pos);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this.Proxy.ExportGuid = binStream.ReadGuid();
            binStream.Read(out this._fk_A);
            this.Proxy.A_pos = binStream.ReadNullableInt32();
            binStream.Read(out this._fk_B);
            this.Proxy.B_pos = binStream.ReadNullableInt32();
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", this.Proxy.ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(this.Proxy.A != null ? this.Proxy.A.ExportGuid : (Guid?)null, xml, "A", "Zetbox.App.Base");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(this.Proxy.A_pos, xml, "A_pos", "Zetbox.App.Base");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(this.Proxy.B != null ? this.Proxy.B.ExportGuid : (Guid?)null, xml, "B", "Zetbox.App.Base");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(this.Proxy.B_pos, xml, "B_pos", "Zetbox.App.Base");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "Zetbox.App.Base|ExportGuid":
                this.Proxy.ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "Zetbox.App.Base|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.Base|A_pos":
                this.Proxy.A_pos = XmlStreamer.ReadNullableInt32(xml);
                break;
            case "Zetbox.App.Base|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.Base|B_pos":
                this.Proxy.B_pos = XmlStreamer.ReadNullableInt32(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(RoleMembership_resolves_Relations_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (RoleMembership_resolves_Relations_RelationEntryNHibernateImpl)obj;
            var me = (RoleMembership_resolves_Relations_RelationEntryNHibernateImpl)this;

            me._fk_A = other._fk_A;
            me.AIndex = other.AIndex;
            me._fk_B = other._fk_B;
            me.BIndex = other.BIndex;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                this.A = ((Zetbox.App.Base.RoleMembershipNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.RoleMembership>(_fk_guid_A.Value));
            else
            if (_fk_A.HasValue)
                this.A = ((Zetbox.App.Base.RoleMembershipNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.RoleMembership>(_fk_A.Value));
            else
                this.A = null;

            if (_fk_guid_B.HasValue)
                this.B = ((Zetbox.App.Base.RelationNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Relation>(_fk_guid_B.Value));
            else
            if (_fk_B.HasValue)
                this.B = ((Zetbox.App.Base.RelationNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Relation>(_fk_B.Value));
            else
                this.B = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }

        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow A
            if (this.A != null && this.A.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.A);
                ((NHibernatePersistenceObject)this.A).ChildrenToDelete.Add(this);
            }

            // Follow B
            if (this.B != null && this.B.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.B);
                ((NHibernatePersistenceObject)this.B).ChildrenToDelete.Add(this);
            }

            // remove from collections manually to notify NHibernate if necessary
            if (this.A != null && this.A.Relations.Contains(this.B)) this.A.Relations.Remove(this.B);

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.A = null;
            this.B = null;
        }

        public class RoleMembership_resolves_Relations_RelationEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public RoleMembership_resolves_Relations_RelationEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(RoleMembership_resolves_Relations_RelationEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(RoleMembership_resolves_Relations_RelationEntryProxy); } }

            public virtual Zetbox.App.Base.RoleMembershipNHibernateImpl.RoleMembershipProxy A { get; set; }

            public virtual Zetbox.App.Base.RelationNHibernateImpl.RelationProxy B { get; set; }

            public virtual int? A_pos { get; set; }

            public virtual int? B_pos { get; set; }

            public virtual Guid ExportGuid { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.SchemaMigration
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("SourceColumn_created_Property_RelationEntryNHibernateImpl")]
    public class SourceColumn_created_Property_RelationEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.RelationEntryNHibernateImpl<Zetbox.App.SchemaMigration.SourceColumn, Zetbox.App.SchemaMigration.SourceColumnNHibernateImpl, Zetbox.App.Base.Property, Zetbox.App.Base.PropertyNHibernateImpl>, SourceColumn_created_Property_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        public SourceColumn_created_Property_RelationEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public SourceColumn_created_Property_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new SourceColumn_created_Property_RelationEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public SourceColumn_created_Property_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, SourceColumn_created_Property_RelationEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly SourceColumn_created_Property_RelationEntryProxy Proxy;

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.ExportGuid;
                if (this.Proxy.ExportGuid == Guid.Empty) {
                    __result = this.Proxy.ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.ExportGuid != value)
                {
                    var __oldValue = Proxy.ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    Proxy.ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("fb27e3f8-3615-4f3b-ae2a-2b89b8782e27");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.SchemaMigration.SourceColumn)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Property)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=this.Proxy.A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.SchemaMigration.SourceColumn; moduleNamespace=Zetbox.App.SchemaMigration;
        // will get inverse collection for notifications for DestinationProperty
        // PositionStorage=A_pos;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.SchemaMigration.SourceColumn A
        {
            get
            {
                Zetbox.App.SchemaMigration.SourceColumnNHibernateImpl __value = (Zetbox.App.SchemaMigration.SourceColumnNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.A == null)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.SchemaMigration.SourceColumnNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);
                var __newValue = (Zetbox.App.SchemaMigration.SourceColumnNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("DestinationProperty", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("DestinationProperty", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.A = null;
                }
                else
                {
                    this.Proxy.A = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.DestinationProperty as IRelationListSync<Zetbox.App.SchemaMigration.SourceColumn_created_Property_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.DestinationProperty as IRelationListSync<Zetbox.App.SchemaMigration.SourceColumn_created_Property_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for A's id, used on dehydration only</summary>
        private int? _fk_A = null;

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return A != null ? A.ID : (int?)null; }
			set { _fk_A = value; }
		}

        /// <summary>Backing store for A's guid, used on import only</summary>
        private Guid? _fk_guid_A = null;

    public Zetbox.API.Async.ZbTask TriggerFetchAAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.SchemaMigration.SourceColumn>(this.A);
    }

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        public virtual int? A_pos
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.A_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.A_pos != value)
                {
                    var __oldValue = Proxy.A_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("A_pos", __oldValue, __newValue);
                    Proxy.A_pos = __newValue;
                    NotifyPropertyChanged("A_pos", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("A_pos");
                }
            }
        }
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=this.Proxy.B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Property; moduleNamespace=Zetbox.App.SchemaMigration;
        // no inverse navigator handling
        // PositionStorage=B_pos;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.Property B
        {
            get
            {
                Zetbox.App.Base.PropertyNHibernateImpl __value = (Zetbox.App.Base.PropertyNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.B == null)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Base.PropertyNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);
                var __newValue = (Zetbox.App.Base.PropertyNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.B = null;
                }
                else
                {
                    this.Proxy.B = __newValue.Proxy;
                }

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for B's id, used on dehydration only</summary>
        private int? _fk_B = null;

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return B != null ? B.ID : (int?)null; }
			set { _fk_B = value; }
		}

        /// <summary>Backing store for B's guid, used on import only</summary>
        private Guid? _fk_guid_B = null;

    public Zetbox.API.Async.ZbTask TriggerFetchBAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Property>(this.B);
    }

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        public virtual int? B_pos
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.B_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.B_pos != value)
                {
                    var __oldValue = Proxy.B_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("B_pos", __oldValue, __newValue);
                    Proxy.B_pos = __newValue;
                    NotifyPropertyChanged("B_pos", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("B_pos");
                }
            }
        }
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        /// <summary>
        /// Index into the A-side list of this relation
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public int? AIndex
        {
            get { return this.A_pos; }
            set { this.A_pos = (int?)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        /// <summary>
        /// Index into the B-side list of this relation
        /// </summary>
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public int? BIndex
        {
            get { return this.B_pos; }
            set { this.B_pos = (int?)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.ExportGuid);
            binStream.Write(this.Proxy.A != null ? OurContext.GetIdFromProxy(this.Proxy.A) : (int?)null);
            binStream.Write(this.Proxy.A_pos);
            binStream.Write(this.Proxy.B != null ? OurContext.GetIdFromProxy(this.Proxy.B) : (int?)null);
            binStream.Write(this.Proxy.B_pos);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this.Proxy.ExportGuid = binStream.ReadGuid();
            binStream.Read(out this._fk_A);
            this.Proxy.A_pos = binStream.ReadNullableInt32();
            binStream.Read(out this._fk_B);
            this.Proxy.B_pos = binStream.ReadNullableInt32();
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", this.Proxy.ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.SchemaMigration")) XmlStreamer.ToStream(this.Proxy.A != null ? this.Proxy.A.ExportGuid : (Guid?)null, xml, "A", "Zetbox.App.SchemaMigration");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.SchemaMigration")) XmlStreamer.ToStream(this.Proxy.A_pos, xml, "A_pos", "Zetbox.App.SchemaMigration");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.SchemaMigration")) XmlStreamer.ToStream(this.Proxy.B != null ? this.Proxy.B.ExportGuid : (Guid?)null, xml, "B", "Zetbox.App.SchemaMigration");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.SchemaMigration")) XmlStreamer.ToStream(this.Proxy.B_pos, xml, "B_pos", "Zetbox.App.SchemaMigration");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "Zetbox.App.SchemaMigration|ExportGuid":
                this.Proxy.ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "Zetbox.App.SchemaMigration|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.SchemaMigration|A_pos":
                this.Proxy.A_pos = XmlStreamer.ReadNullableInt32(xml);
                break;
            case "Zetbox.App.SchemaMigration|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.SchemaMigration|B_pos":
                this.Proxy.B_pos = XmlStreamer.ReadNullableInt32(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(SourceColumn_created_Property_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (SourceColumn_created_Property_RelationEntryNHibernateImpl)obj;
            var me = (SourceColumn_created_Property_RelationEntryNHibernateImpl)this;

            me._fk_A = other._fk_A;
            me.AIndex = other.AIndex;
            me._fk_B = other._fk_B;
            me.BIndex = other.BIndex;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                this.A = ((Zetbox.App.SchemaMigration.SourceColumnNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.SchemaMigration.SourceColumn>(_fk_guid_A.Value));
            else
            if (_fk_A.HasValue)
                this.A = ((Zetbox.App.SchemaMigration.SourceColumnNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.SchemaMigration.SourceColumn>(_fk_A.Value));
            else
                this.A = null;

            if (_fk_guid_B.HasValue)
                this.B = ((Zetbox.App.Base.PropertyNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Property>(_fk_guid_B.Value));
            else
            if (_fk_B.HasValue)
                this.B = ((Zetbox.App.Base.PropertyNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Property>(_fk_B.Value));
            else
                this.B = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }

        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow A
            if (this.A != null && this.A.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.A);
                ((NHibernatePersistenceObject)this.A).ChildrenToDelete.Add(this);
            }

            // Follow B
            if (this.B != null && this.B.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.B);
                ((NHibernatePersistenceObject)this.B).ChildrenToDelete.Add(this);
            }

            // remove from collections manually to notify NHibernate if necessary
            if (this.A != null && this.A.DestinationProperty.Contains(this.B)) this.A.DestinationProperty.Remove(this.B);

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.A = null;
            this.B = null;
        }

        public class SourceColumn_created_Property_RelationEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public SourceColumn_created_Property_RelationEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(SourceColumn_created_Property_RelationEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(SourceColumn_created_Property_RelationEntryProxy); } }

            public virtual Zetbox.App.SchemaMigration.SourceColumnNHibernateImpl.SourceColumnProxy A { get; set; }

            public virtual Zetbox.App.Base.PropertyNHibernateImpl.PropertyProxy B { get; set; }

            public virtual int? A_pos { get; set; }

            public virtual int? B_pos { get; set; }

            public virtual Guid ExportGuid { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.Test
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("Student_füllt_aus_Testbogen_RelationEntryNHibernateImpl")]
    public class Student_füllt_aus_Testbogen_RelationEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.RelationEntryNHibernateImpl<Zetbox.App.Test.TestStudent, Zetbox.App.Test.TestStudentNHibernateImpl, Zetbox.App.Test.Fragebogen, Zetbox.App.Test.FragebogenNHibernateImpl>, Student_füllt_aus_Testbogen_RelationEntry
    {
        public Student_füllt_aus_Testbogen_RelationEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public Student_füllt_aus_Testbogen_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new Student_füllt_aus_Testbogen_RelationEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public Student_füllt_aus_Testbogen_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, Student_füllt_aus_Testbogen_RelationEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly Student_füllt_aus_Testbogen_RelationEntryProxy Proxy;
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("6819ca86-571c-4d59-bc30-cc1fb0decc9e");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Test.TestStudent)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Test.Fragebogen)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=this.Proxy.A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Test.TestStudent; moduleNamespace=Zetbox.App.Test;
        // will get inverse collection for notifications for Testbogen
        // PositionStorage=none;
        // Target not exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Test.TestStudent A
        {
            get
            {
                Zetbox.App.Test.TestStudentNHibernateImpl __value = (Zetbox.App.Test.TestStudentNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.A == null)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Test.TestStudentNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);
                var __newValue = (Zetbox.App.Test.TestStudentNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("Testbogen", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("Testbogen", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.A = null;
                }
                else
                {
                    this.Proxy.A = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.Testbogen as IRelationListSync<Zetbox.App.Test.Student_füllt_aus_Testbogen_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.Testbogen as IRelationListSync<Zetbox.App.Test.Student_füllt_aus_Testbogen_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for A's id, used on dehydration only</summary>
        private int? _fk_A = null;

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return A != null ? A.ID : (int?)null; }
			set { _fk_A = value; }
		}


    public Zetbox.API.Async.ZbTask TriggerFetchAAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Test.TestStudent>(this.A);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=this.Proxy.B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Test.Fragebogen; moduleNamespace=Zetbox.App.Test;
        // will get inverse collection for notifications for Student
        // PositionStorage=none;
        // Target not exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Test.Fragebogen B
        {
            get
            {
                Zetbox.App.Test.FragebogenNHibernateImpl __value = (Zetbox.App.Test.FragebogenNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.B == null)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Test.FragebogenNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);
                var __newValue = (Zetbox.App.Test.FragebogenNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("Student", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("Student", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.B = null;
                }
                else
                {
                    this.Proxy.B = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.Student as IRelationListSync<Zetbox.App.Test.Student_füllt_aus_Testbogen_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.Student as IRelationListSync<Zetbox.App.Test.Student_füllt_aus_Testbogen_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for B's id, used on dehydration only</summary>
        private int? _fk_B = null;

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return B != null ? B.ID : (int?)null; }
			set { _fk_B = value; }
		}


    public Zetbox.API.Async.ZbTask TriggerFetchBAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Test.Fragebogen>(this.B);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.A != null ? OurContext.GetIdFromProxy(this.Proxy.A) : (int?)null);
            binStream.Write(this.Proxy.B != null ? OurContext.GetIdFromProxy(this.Proxy.B) : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            binStream.Read(out this._fk_A);
            binStream.Read(out this._fk_B);
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Student_füllt_aus_Testbogen_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Student_füllt_aus_Testbogen_RelationEntryNHibernateImpl)obj;
            var me = (Student_füllt_aus_Testbogen_RelationEntryNHibernateImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_A.HasValue)
                this.A = ((Zetbox.App.Test.TestStudentNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Test.TestStudent>(_fk_A.Value));
            else
                this.A = null;

            if (_fk_B.HasValue)
                this.B = ((Zetbox.App.Test.FragebogenNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Test.Fragebogen>(_fk_B.Value));
            else
                this.B = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }

        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow A
            if (this.A != null && this.A.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.A);
                ((NHibernatePersistenceObject)this.A).ChildrenToDelete.Add(this);
            }

            // Follow B
            if (this.B != null && this.B.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.B);
                ((NHibernatePersistenceObject)this.B).ChildrenToDelete.Add(this);
            }

            // remove from collections manually to notify NHibernate if necessary
            if (this.A != null && this.A.Testbogen.Contains(this.B)) this.A.Testbogen.Remove(this.B);
            else
            // The other direction is handled by the infrastructure (but A might be null)
            if (this.B != null && this.B.Student.Contains(this.A)) this.B.Student.Remove(this.A);

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.A = null;
            this.B = null;
        }

        public class Student_füllt_aus_Testbogen_RelationEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public Student_füllt_aus_Testbogen_RelationEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(Student_füllt_aus_Testbogen_RelationEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(Student_füllt_aus_Testbogen_RelationEntryProxy); } }

            public virtual Zetbox.App.Test.TestStudentNHibernateImpl.TestStudentProxy A { get; set; }

            public virtual Zetbox.App.Test.FragebogenNHibernateImpl.FragebogenProxy B { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.Base
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("UniqueContraints_ensures_unique_on_Properties_RelationEntryNHibernateImpl")]
    public class UniqueContraints_ensures_unique_on_Properties_RelationEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.RelationEntryNHibernateImpl<Zetbox.App.Base.IndexConstraint, Zetbox.App.Base.IndexConstraintNHibernateImpl, Zetbox.App.Base.Property, Zetbox.App.Base.PropertyNHibernateImpl>, UniqueContraints_ensures_unique_on_Properties_RelationEntry, Zetbox.API.IExportableInternal, Zetbox.App.Base.IExportable
    {
        public UniqueContraints_ensures_unique_on_Properties_RelationEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public UniqueContraints_ensures_unique_on_Properties_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new UniqueContraints_ensures_unique_on_Properties_RelationEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public UniqueContraints_ensures_unique_on_Properties_RelationEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, UniqueContraints_ensures_unique_on_Properties_RelationEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly UniqueContraints_ensures_unique_on_Properties_RelationEntryProxy Proxy;

        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.ExportGuid;
                if (this.Proxy.ExportGuid == Guid.Empty) {
                    __result = this.Proxy.ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.ExportGuid != value)
                {
                    var __oldValue = Proxy.ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    Proxy.ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("ExportGuid");
                }
            }
        }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("29235ba6-5979-4ed8-8e75-6bd0837c7f28");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Zetbox.App.Base.IndexConstraint)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Zetbox.App.Base.Property)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=this.Proxy.A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Zetbox.App.Base.IndexConstraint; moduleNamespace=Zetbox.App.Base;
        // will get inverse collection for notifications for Properties
        // PositionStorage=none;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.IndexConstraint A
        {
            get
            {
                Zetbox.App.Base.IndexConstraintNHibernateImpl __value = (Zetbox.App.Base.IndexConstraintNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.A == null)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Base.IndexConstraintNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.A);
                var __newValue = (Zetbox.App.Base.IndexConstraintNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("A");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("Properties", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("Properties", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.A = null;
                }
                else
                {
                    this.Proxy.A = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.Properties as IRelationListSync<Zetbox.App.Base.UniqueContraints_ensures_unique_on_Properties_RelationEntryNHibernateImpl>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.Properties as IRelationListSync<Zetbox.App.Base.UniqueContraints_ensures_unique_on_Properties_RelationEntryNHibernateImpl>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for A's id, used on dehydration only</summary>
        private int? _fk_A = null;

        /// <summary>ForeignKey Property for A's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_A
		{
			get { return A != null ? A.ID : (int?)null; }
			set { _fk_A = value; }
		}

        /// <summary>Backing store for A's guid, used on import only</summary>
        private Guid? _fk_guid_A = null;

    public Zetbox.API.Async.ZbTask TriggerFetchAAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Base.IndexConstraint>(this.A);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=this.Proxy.B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Zetbox.App.Base.Property; moduleNamespace=Zetbox.App.Base;
        // no inverse navigator handling
        // PositionStorage=none;
        // Target exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.Property B
        {
            get
            {
                Zetbox.App.Base.PropertyNHibernateImpl __value = (Zetbox.App.Base.PropertyNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.B == null)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Base.PropertyNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.B);
                var __newValue = (Zetbox.App.Base.PropertyNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("B");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.B = null;
                }
                else
                {
                    this.Proxy.B = __newValue.Proxy;
                }

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for B's id, used on dehydration only</summary>
        private int? _fk_B = null;

        /// <summary>ForeignKey Property for B's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_B
		{
			get { return B != null ? B.ID : (int?)null; }
			set { _fk_B = value; }
		}

        /// <summary>Backing store for B's guid, used on import only</summary>
        private Guid? _fk_guid_B = null;

    public Zetbox.API.Async.ZbTask TriggerFetchBAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Base.Property>(this.B);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.ExportGuid);
            binStream.Write(this.Proxy.A != null ? OurContext.GetIdFromProxy(this.Proxy.A) : (int?)null);
            binStream.Write(this.Proxy.B != null ? OurContext.GetIdFromProxy(this.Proxy.B) : (int?)null);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            this.Proxy.ExportGuid = binStream.ReadGuid();
            binStream.Read(out this._fk_A);
            binStream.Read(out this._fk_B);
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", this.Proxy.ExportGuid.ToString());
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(this.Proxy.A != null ? this.Proxy.A.ExportGuid : (Guid?)null, xml, "A", "Zetbox.App.Base");
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Base")) XmlStreamer.ToStream(this.Proxy.B != null ? this.Proxy.B.ExportGuid : (Guid?)null, xml, "B", "Zetbox.App.Base");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "Zetbox.App.Base|ExportGuid":
                this.Proxy.ExportGuid = XmlStreamer.ReadGuid(xml);
                break;
            case "Zetbox.App.Base|A":
                this._fk_guid_A = XmlStreamer.ReadNullableGuid(xml);
                break;
            case "Zetbox.App.Base|B":
                this._fk_guid_B = XmlStreamer.ReadNullableGuid(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(UniqueContraints_ensures_unique_on_Properties_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (UniqueContraints_ensures_unique_on_Properties_RelationEntryNHibernateImpl)obj;
            var me = (UniqueContraints_ensures_unique_on_Properties_RelationEntryNHibernateImpl)this;

            me._fk_A = other._fk_A;
            me._fk_B = other._fk_B;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                this.A = ((Zetbox.App.Base.IndexConstraintNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.IndexConstraint>(_fk_guid_A.Value));
            else
            if (_fk_A.HasValue)
                this.A = ((Zetbox.App.Base.IndexConstraintNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.IndexConstraint>(_fk_A.Value));
            else
                this.A = null;

            if (_fk_guid_B.HasValue)
                this.B = ((Zetbox.App.Base.PropertyNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Property>(_fk_guid_B.Value));
            else
            if (_fk_B.HasValue)
                this.B = ((Zetbox.App.Base.PropertyNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Base.Property>(_fk_B.Value));
            else
                this.B = null;

        }


        protected override void OnPropertyChanged(string property, object oldValue, object newValue)
        {
            base.OnPropertyChanged(property, oldValue, newValue);

            if (property == "A" || property == "B")
            {
                var oldNotifier = (INotifyPropertyChanged)oldValue;
                var newNotifier = (INotifyPropertyChanged)newValue;

                if (oldNotifier != null) oldNotifier.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                if (newNotifier != null) newNotifier.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(AB_PropertyChanged);
                ManageMyObjectState();
            }
        }

        void AB_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "ObjectState")
            {
                ManageMyObjectState();
            }
        }

        private void ManageMyObjectState()
        {
            if (A != null && A.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);
            if (B != null && B.ObjectState == DataObjectState.Deleted && this.Context != null)
                this.Context.Delete(this);

            if (this.ObjectState == DataObjectState.Deleted && A != null && B != null && A.ObjectState != DataObjectState.Deleted && B.ObjectState != DataObjectState.Deleted)
                this.SetUnDeleted();
        }

        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow A
            if (this.A != null && this.A.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.A);
                ((NHibernatePersistenceObject)this.A).ChildrenToDelete.Add(this);
            }

            // Follow B
            if (this.B != null && this.B.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.B);
                ((NHibernatePersistenceObject)this.B).ChildrenToDelete.Add(this);
            }

            // remove from collections manually to notify NHibernate if necessary
            if (this.A != null && this.A.Properties.Contains(this.B)) this.A.Properties.Remove(this.B);

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.A = null;
            this.B = null;
        }

        public class UniqueContraints_ensures_unique_on_Properties_RelationEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public UniqueContraints_ensures_unique_on_Properties_RelationEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(UniqueContraints_ensures_unique_on_Properties_RelationEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(UniqueContraints_ensures_unique_on_Properties_RelationEntryProxy); } }

            public virtual Zetbox.App.Base.IndexConstraintNHibernateImpl.IndexConstraintProxy A { get; set; }

            public virtual Zetbox.App.Base.PropertyNHibernateImpl.PropertyProxy B { get; set; }

            public virtual Guid ExportGuid { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Zetbox.App.Projekte
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.ValueCollectionEntry
    [System.Diagnostics.DebuggerDisplay("Kunde_EMails_CollectionEntryNHibernateImpl")]
    public class Kunde_EMails_CollectionEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.ValueCollectionEntryNHibernateImpl<Zetbox.App.Projekte.Kunde, Zetbox.App.Projekte.KundeNHibernateImpl, string>, Kunde_EMails_CollectionEntry, Zetbox.API.IExportableValueCollectionEntryInternal
    {
        public Kunde_EMails_CollectionEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public Kunde_EMails_CollectionEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new Kunde_EMails_CollectionEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public Kunde_EMails_CollectionEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, Kunde_EMails_CollectionEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly Kunde_EMails_CollectionEntryProxy Proxy;
        private static readonly Guid _propertyID = new Guid("1d0f6da6-4b69-48d7-9e94-bfb5466654b9");
        public override Guid PropertyID { get { return _propertyID; } }


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for Parent
        // fkBackingName=this.Proxy.Parent; fkGuidBackingName=unused;
        // referencedInterface=Zetbox.App.Projekte.Kunde; moduleNamespace=Zetbox.App.Projekte;
        // inverse Navigator=EMails; is list;
        // PositionStorage=none;
        // Target not exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Projekte.Kunde Parent
        {
            get
            {
                Zetbox.App.Projekte.KundeNHibernateImpl __value = (Zetbox.App.Projekte.KundeNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.Parent);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.Parent == null)
                {
                    SetInitializedProperty("Parent");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Projekte.KundeNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.Parent);
                var __newValue = (Zetbox.App.Projekte.KundeNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("Parent");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("Parent", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("EMails", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("EMails", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.Parent = null;
                }
                else
                {
                    this.Proxy.Parent = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.EMails as IRelationListSync<Kunde_EMails_CollectionEntry>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.EMails as IRelationListSync<Kunde_EMails_CollectionEntry>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("Parent", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for Parent's id, used on dehydration only</summary>
        private int? _fk_Parent = null;

        /// <summary>ForeignKey Property for Parent's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_Parent
		{
			get { return Parent != null ? Parent.ID : (int?)null; }
			set { _fk_Parent = value; }
		}


    public Zetbox.API.Async.ZbTask TriggerFetchParentAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Projekte.Kunde>(this.Parent);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for Parent
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.API.IDataObject ParentObject
        {
            get { return Parent; }
            set { Parent = (Zetbox.App.Projekte.KundeNHibernateImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        public virtual string Value
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.Value;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.Value != value)
                {
                    var __oldValue = Proxy.Value;
                    var __newValue = value;
                    NotifyPropertyChanging("Value", __oldValue, __newValue);
                    Proxy.Value = __newValue;
                    NotifyPropertyChanged("Value", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("Value");
                }
            }
        }
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public object ValueObject
        {
            get { return Value; }
            set { Value = (string)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.Parent != null ? OurContext.GetIdFromProxy(this.Proxy.Parent) : (int?)null);
            binStream.Write(this.Proxy.Value);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            binStream.Read(out this._fk_Parent);
            this.Proxy.Value = binStream.ReadString();
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Projekte")) XmlStreamer.ToStream(this.Proxy.Value, xml, "Value", "Zetbox.App.Projekte");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "Zetbox.App.Projekte|Value":
                this.Proxy.Value = XmlStreamer.ReadString(xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Kunde_EMails_CollectionEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Kunde_EMails_CollectionEntryNHibernateImpl)obj;
            var me = (Kunde_EMails_CollectionEntryNHibernateImpl)this;

            me._fk_Parent = other._fk_Parent;
            me.Value = other.Value;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_Parent.HasValue)
                this.Parent = ((Zetbox.App.Projekte.KundeNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Projekte.Kunde>(_fk_Parent.Value));
            else
                this.Parent = null;

        }


        public override void UpdateParent(string propertyName, IDataObject parentObj)
        {
            switch(propertyName)
            {
                case "Parent":
                    {
                        var __oldValue = (Zetbox.App.Projekte.KundeNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.Parent);
                        var __newValue = (Zetbox.App.Projekte.KundeNHibernateImpl)parentObj;
                        NotifyPropertyChanging("Parent", __oldValue, __newValue);
                        this.Proxy.Parent = __newValue == null ? null : __newValue.Proxy;
                        NotifyPropertyChanged("Parent", __oldValue, __newValue);
                    }
                    break;
                default:
                    base.UpdateParent(propertyName, parentObj);
                    break;
            }
        }
        public override void SaveOrUpdateTo(NHibernate.ISession session)
        {
            // ValueCollectionEntries and CompoundCollectionEntries are saved by cascade
            //base.SaveOrUpdateTo(session);
        }


        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow Parent
            if (this.Parent != null && this.Parent.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.Parent);
                ((NHibernatePersistenceObject)this.Parent).ChildrenToDelete.Add(this);
            }

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.Parent = null;
        }

        public class Kunde_EMails_CollectionEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public Kunde_EMails_CollectionEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(Kunde_EMails_CollectionEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(Kunde_EMails_CollectionEntryProxy); } }

            public virtual Zetbox.App.Projekte.KundeNHibernateImpl.KundeProxy Parent { get; set; }

            public virtual bool ValueIsNull { get; set; }

            public virtual string Value { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.ValueCollectionEntry
}

namespace Zetbox.App.Test
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.ValueCollectionEntry
    [System.Diagnostics.DebuggerDisplay("Muhblah_StringCollection_CollectionEntryNHibernateImpl")]
    public class Muhblah_StringCollection_CollectionEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.ValueCollectionEntryNHibernateImpl<Zetbox.App.Test.Muhblah, Zetbox.App.Test.MuhblahNHibernateImpl, string>, Muhblah_StringCollection_CollectionEntry
    {
        public Muhblah_StringCollection_CollectionEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public Muhblah_StringCollection_CollectionEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new Muhblah_StringCollection_CollectionEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public Muhblah_StringCollection_CollectionEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, Muhblah_StringCollection_CollectionEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly Muhblah_StringCollection_CollectionEntryProxy Proxy;
        private static readonly Guid _propertyID = new Guid("b89fc0d2-8603-40d7-8649-61431a9fb09b");
        public override Guid PropertyID { get { return _propertyID; } }


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for Parent
        // fkBackingName=this.Proxy.Parent; fkGuidBackingName=unused;
        // referencedInterface=Zetbox.App.Test.Muhblah; moduleNamespace=Zetbox.App.Test;
        // inverse Navigator=StringCollection; is list;
        // PositionStorage=none;
        // Target not exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Test.Muhblah Parent
        {
            get
            {
                Zetbox.App.Test.MuhblahNHibernateImpl __value = (Zetbox.App.Test.MuhblahNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.Parent);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.Parent == null)
                {
                    SetInitializedProperty("Parent");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Test.MuhblahNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.Parent);
                var __newValue = (Zetbox.App.Test.MuhblahNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("Parent");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("Parent", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("StringCollection", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("StringCollection", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.Parent = null;
                }
                else
                {
                    this.Proxy.Parent = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.StringCollection as IRelationListSync<Muhblah_StringCollection_CollectionEntry>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.StringCollection as IRelationListSync<Muhblah_StringCollection_CollectionEntry>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("Parent", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for Parent's id, used on dehydration only</summary>
        private int? _fk_Parent = null;

        /// <summary>ForeignKey Property for Parent's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_Parent
		{
			get { return Parent != null ? Parent.ID : (int?)null; }
			set { _fk_Parent = value; }
		}


    public Zetbox.API.Async.ZbTask TriggerFetchParentAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Test.Muhblah>(this.Parent);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for Parent
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.API.IDataObject ParentObject
        {
            get { return Parent; }
            set { Parent = (Zetbox.App.Test.MuhblahNHibernateImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        public virtual string Value
        {
            get
            {
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = Proxy.Value;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (Proxy.Value != value)
                {
                    var __oldValue = Proxy.Value;
                    var __newValue = value;
                    NotifyPropertyChanging("Value", __oldValue, __newValue);
                    Proxy.Value = __newValue;
                    NotifyPropertyChanged("Value", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;

                }
                else
                {
                    SetInitializedProperty("Value");
                }
            }
        }
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.NotifyingValueProperty
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public object ValueObject
        {
            get { return Value; }
            set { Value = (string)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.Parent != null ? OurContext.GetIdFromProxy(this.Proxy.Parent) : (int?)null);
            binStream.Write(this.Proxy.Value);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            binStream.Read(out this._fk_Parent);
            this.Proxy.Value = binStream.ReadString();
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Muhblah_StringCollection_CollectionEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Muhblah_StringCollection_CollectionEntryNHibernateImpl)obj;
            var me = (Muhblah_StringCollection_CollectionEntryNHibernateImpl)this;

            me._fk_Parent = other._fk_Parent;
            me.Value = other.Value;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_Parent.HasValue)
                this.Parent = ((Zetbox.App.Test.MuhblahNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Test.Muhblah>(_fk_Parent.Value));
            else
                this.Parent = null;

        }


        public override void UpdateParent(string propertyName, IDataObject parentObj)
        {
            switch(propertyName)
            {
                case "Parent":
                    {
                        var __oldValue = (Zetbox.App.Test.MuhblahNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.Parent);
                        var __newValue = (Zetbox.App.Test.MuhblahNHibernateImpl)parentObj;
                        NotifyPropertyChanging("Parent", __oldValue, __newValue);
                        this.Proxy.Parent = __newValue == null ? null : __newValue.Proxy;
                        NotifyPropertyChanged("Parent", __oldValue, __newValue);
                    }
                    break;
                default:
                    base.UpdateParent(propertyName, parentObj);
                    break;
            }
        }
        public override void SaveOrUpdateTo(NHibernate.ISession session)
        {
            // ValueCollectionEntries and CompoundCollectionEntries are saved by cascade
            //base.SaveOrUpdateTo(session);
        }


        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow Parent
            if (this.Parent != null && this.Parent.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.Parent);
                ((NHibernatePersistenceObject)this.Parent).ChildrenToDelete.Add(this);
            }

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.Parent = null;
        }

        public class Muhblah_StringCollection_CollectionEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public Muhblah_StringCollection_CollectionEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(Muhblah_StringCollection_CollectionEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(Muhblah_StringCollection_CollectionEntryProxy); } }

            public virtual Zetbox.App.Test.MuhblahNHibernateImpl.MuhblahProxy Parent { get; set; }

            public virtual bool ValueIsNull { get; set; }

            public virtual string Value { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.ValueCollectionEntry
}

namespace Zetbox.App.Projekte
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.ValueCollectionEntry
    [System.Diagnostics.DebuggerDisplay("Projekt_AuditJournal_CollectionEntryNHibernateImpl")]
    public class Projekt_AuditJournal_CollectionEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.CompoundCollectionEntryNHibernateImpl<Zetbox.App.Projekte.Projekt, Zetbox.App.Projekte.ProjektNHibernateImpl, Zetbox.App.Base.AuditEntry, Zetbox.App.Base.AuditEntryNHibernateImpl>, Projekt_AuditJournal_CollectionEntry, Zetbox.API.IExportableValueCollectionEntryInternal
    {
        public Projekt_AuditJournal_CollectionEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public Projekt_AuditJournal_CollectionEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new Projekt_AuditJournal_CollectionEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public Projekt_AuditJournal_CollectionEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, Projekt_AuditJournal_CollectionEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
            if (this.Proxy.Value == null)
            {
                this.Proxy.Value = new Zetbox.App.Base.AuditEntryNHibernateImpl(this, "Value", lazyCtx, null);
            }
            else
            {
                this.Proxy.Value.AttachToObject(this, "Value");
            }

        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly Projekt_AuditJournal_CollectionEntryProxy Proxy;
        private static readonly Guid _propertyID = new Guid("4bef0e48-79c8-4776-a5de-bbb250599a40");
        public override Guid PropertyID { get { return _propertyID; } }


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for Parent
        // fkBackingName=this.Proxy.Parent; fkGuidBackingName=unused;
        // referencedInterface=Zetbox.App.Projekte.Projekt; moduleNamespace=Zetbox.App.Projekte;
        // inverse Navigator=AuditJournal; is list;
        // PositionStorage=none;
        // Target not exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Projekte.Projekt Parent
        {
            get
            {
                Zetbox.App.Projekte.ProjektNHibernateImpl __value = (Zetbox.App.Projekte.ProjektNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.Parent);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.Parent == null)
                {
                    SetInitializedProperty("Parent");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Projekte.ProjektNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.Parent);
                var __newValue = (Zetbox.App.Projekte.ProjektNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("Parent");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("Parent", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("AuditJournal", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("AuditJournal", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.Parent = null;
                }
                else
                {
                    this.Proxy.Parent = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.AuditJournal as IRelationListSync<Projekt_AuditJournal_CollectionEntry>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.AuditJournal as IRelationListSync<Projekt_AuditJournal_CollectionEntry>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("Parent", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for Parent's id, used on dehydration only</summary>
        private int? _fk_Parent = null;

        /// <summary>ForeignKey Property for Parent's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_Parent
		{
			get { return Parent != null ? Parent.ID : (int?)null; }
			set { _fk_Parent = value; }
		}


    public Zetbox.API.Async.ZbTask TriggerFetchParentAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Projekte.Projekt>(this.Parent);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for Parent
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.API.IDataObject ParentObject
        {
            get { return Parent; }
            set { Parent = (Zetbox.App.Projekte.ProjektNHibernateImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.CompoundObjectPropertyTemplate
        // implement the user-visible interface
        public Zetbox.App.Base.AuditEntry Value
        {
            get { return ValueImpl; }
            set { ValueImpl = (Zetbox.App.Base.AuditEntryNHibernateImpl)value; }
        }

        /// <summary>backing property for Value, takes care of attaching/detaching the values</summary>
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Base.AuditEntryNHibernateImpl ValueImpl
        {
            get
            {
                return this.Proxy.Value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value == null)
                    throw new ArgumentNullException("value");
                if (!object.Equals(this.Proxy.Value, value))
                {
                    var __oldValue = this.Proxy.Value;
                    var __newValue = value;

                    NotifyPropertyChanging("Value", __oldValue, __newValue);

                    if (this.Proxy.Value != null)
                    {
                        this.Proxy.Value.DetachFromObject(this, "Value");
                    }
                    __newValue = (Zetbox.App.Base.AuditEntryNHibernateImpl)__newValue.Clone();
                    this.Proxy.Value = __newValue;
                    this.Proxy.Value.AttachToObject(this, "Value");

                    NotifyPropertyChanged("Value", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;
                }
            }
        }
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.CompoundObjectPropertyTemplate        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public object ValueObject
        {
            get { return Value; }
            set { Value = (Zetbox.App.Base.AuditEntryNHibernateImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.Parent != null ? OurContext.GetIdFromProxy(this.Proxy.Parent) : (int?)null);
            binStream.Write(this.Value);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            binStream.Read(out this._fk_Parent);
            {
                // use backing store to avoid notifications
                this.ValueImpl = binStream.ReadCompoundObject<Zetbox.App.Base.AuditEntryNHibernateImpl>();
                this.ValueImpl.AttachToObject(this, "Value");
            }
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            if (modules.Contains("*") || modules.Contains("Zetbox.App.Projekte")) XmlStreamer.ExportCompoundObject(this.Value, xml, "Value", "Zetbox.App.Projekte");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            switch (xml.NamespaceURI + "|" + xml.LocalName) {
            case "Zetbox.App.Projekte|Value":
                XmlStreamer.MergeImportCompoundObject(this.ValueImpl, xml);
                break;
            }
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Projekt_AuditJournal_CollectionEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Projekt_AuditJournal_CollectionEntryNHibernateImpl)obj;
            var me = (Projekt_AuditJournal_CollectionEntryNHibernateImpl)this;

            me._fk_Parent = other._fk_Parent;
            if (me.Value == null && other.Value != null) {
                me.Value = (Zetbox.App.Base.AuditEntry)other.Value.Clone();
            } else if (me.Value != null && other.Value == null) {
                me.Value = null;
            } else if (me.Value != null && other.Value != null) {
                me.Value.ApplyChangesFrom(other.Value);
            }
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_Parent.HasValue)
                this.Parent = ((Zetbox.App.Projekte.ProjektNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Projekte.Projekt>(_fk_Parent.Value));
            else
                this.Parent = null;

        }


        public override void UpdateParent(string propertyName, IDataObject parentObj)
        {
            switch(propertyName)
            {
                case "Parent":
                    {
                        var __oldValue = (Zetbox.App.Projekte.ProjektNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.Parent);
                        var __newValue = (Zetbox.App.Projekte.ProjektNHibernateImpl)parentObj;
                        NotifyPropertyChanging("Parent", __oldValue, __newValue);
                        this.Proxy.Parent = __newValue == null ? null : __newValue.Proxy;
                        NotifyPropertyChanged("Parent", __oldValue, __newValue);
                    }
                    break;
                default:
                    base.UpdateParent(propertyName, parentObj);
                    break;
            }
        }
        public override void SaveOrUpdateTo(NHibernate.ISession session)
        {
            // ValueCollectionEntries and CompoundCollectionEntries are saved by cascade
            //base.SaveOrUpdateTo(session);
        }


        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow Parent
            if (this.Parent != null && this.Parent.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.Parent);
                ((NHibernatePersistenceObject)this.Parent).ChildrenToDelete.Add(this);
            }

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.Parent = null;
        }

        public class Projekt_AuditJournal_CollectionEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public Projekt_AuditJournal_CollectionEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(Projekt_AuditJournal_CollectionEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(Projekt_AuditJournal_CollectionEntryProxy); } }

            public virtual Zetbox.App.Projekte.ProjektNHibernateImpl.ProjektProxy Parent { get; set; }

            public virtual bool ValueIsNull { get; set; }

            public virtual Zetbox.App.Base.AuditEntryNHibernateImpl Value { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.ValueCollectionEntry
}

namespace Zetbox.App.Test
{
    // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.ValueCollectionEntry
    [System.Diagnostics.DebuggerDisplay("TestCustomObject_PhoneNumbersOther_CollectionEntryNHibernateImpl")]
    public class TestCustomObject_PhoneNumbersOther_CollectionEntryNHibernateImpl : Zetbox.DalProvider.NHibernate.CompoundCollectionEntryNHibernateImpl<Zetbox.App.Test.TestCustomObject, Zetbox.App.Test.TestCustomObjectNHibernateImpl, Zetbox.App.Test.TestPhoneCompoundObject, Zetbox.App.Test.TestPhoneCompoundObjectNHibernateImpl>, TestCustomObject_PhoneNumbersOther_CollectionEntry
    {
        public TestCustomObject_PhoneNumbersOther_CollectionEntryNHibernateImpl()
            : this(null)
        {
        }

        /// <summary>Create a new unattached instance</summary>
        public TestCustomObject_PhoneNumbersOther_CollectionEntryNHibernateImpl(Func<IFrozenContext> lazyCtx)
            : this(lazyCtx, new TestCustomObject_PhoneNumbersOther_CollectionEntryProxy())
        {
        }

        /// <summary>Create a instance, wrapping the specified proxy</summary>
        public TestCustomObject_PhoneNumbersOther_CollectionEntryNHibernateImpl(Func<IFrozenContext> lazyCtx, TestCustomObject_PhoneNumbersOther_CollectionEntryProxy proxy)
            : base(lazyCtx) // do not pass proxy to base data object
        {
            this.Proxy = proxy;
            if (this.Proxy.Value == null)
            {
                this.Proxy.Value = new Zetbox.App.Test.TestPhoneCompoundObjectNHibernateImpl(this, "Value", lazyCtx, null);
            }
            else
            {
                this.Proxy.Value.AttachToObject(this, "Value");
            }

        }

        /// <summary>the NHibernate proxy of the represented entity</summary>
        internal readonly TestCustomObject_PhoneNumbersOther_CollectionEntryProxy Proxy;
        private static readonly Guid _propertyID = new Guid("0c0c1101-118a-4ce2-806c-d30a03b19dde");
        public override Guid PropertyID { get { return _propertyID; } }


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for Parent
        // fkBackingName=this.Proxy.Parent; fkGuidBackingName=unused;
        // referencedInterface=Zetbox.App.Test.TestCustomObject; moduleNamespace=Zetbox.App.Test;
        // inverse Navigator=PhoneNumbersOther; is list;
        // PositionStorage=none;
        // Target not exportable; does not call events

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Test.TestCustomObject Parent
        {
            get
            {
                Zetbox.App.Test.TestCustomObjectNHibernateImpl __value = (Zetbox.App.Test.TestCustomObjectNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.Parent);


                return __value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongZetboxContextException();

                // shortcut noop with nulls
                if (value == null && this.Proxy.Parent == null)
                {
                    SetInitializedProperty("Parent");
                    return;
                }

                // cache old value to remove inverse references later
                var __oldValue = (Zetbox.App.Test.TestCustomObjectNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.Parent);
                var __newValue = (Zetbox.App.Test.TestCustomObjectNHibernateImpl)value;

                // shortcut noop on objects
                // can't use proxy's ID here, since that might be INVALIDID before persisting the first time.
                if (__oldValue == __newValue)
                {
                    SetInitializedProperty("Parent");
                    return;
                }

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("Parent", __oldValue, __newValue);

                if (__oldValue != null) {
                    __oldValue.NotifyPropertyChanging("PhoneNumbersOther", null, null);
                }
                if (__newValue != null) {
                    __newValue.NotifyPropertyChanging("PhoneNumbersOther", null, null);
                }

                // next, set the local reference
                if (__newValue == null)
                {
                    this.Proxy.Parent = null;
                }
                else
                {
                    this.Proxy.Parent = __newValue.Proxy;
                }

                // now fixup redundant, inverse references
                // The inverse navigator will also fire events when changed, so should
                // only be touched after setting the local value above.
                // TODO: for complete correctness, the "other" Changing event should also fire
                //       before the local value is changed
                if (__oldValue != null)
                {
                    // remove from old list
                    (__oldValue.PhoneNumbersOther as IRelationListSync<TestCustomObject_PhoneNumbersOther_CollectionEntry>).RemoveWithoutClearParent(this);
                }

                if (__newValue != null)
                {
                    // add to new list
                    (__newValue.PhoneNumbersOther as IRelationListSync<TestCustomObject_PhoneNumbersOther_CollectionEntry>).AddWithoutSetParent(this);
                }
                // everything is done. fire the Changed event
                NotifyPropertyChanged("Parent", __oldValue, __newValue);
                if(IsAttached) UpdateChangedInfo = true;

            }
        }

        /// <summary>Backing store for Parent's id, used on dehydration only</summary>
        private int? _fk_Parent = null;

        /// <summary>ForeignKey Property for Parent's id, used on APIs only</summary>
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public int? FK_Parent
		{
			get { return Parent != null ? Parent.ID : (int?)null; }
			set { _fk_Parent = value; }
		}


    public Zetbox.API.Async.ZbTask TriggerFetchParentAsync()
    {
        return new Zetbox.API.Async.ZbTask<Zetbox.App.Test.TestCustomObject>(this.Parent);
    }

        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.ObjectReferencePropertyTemplate for Parent
        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public Zetbox.API.IDataObject ParentObject
        {
            get { return Parent; }
            set { Parent = (Zetbox.App.Test.TestCustomObjectNHibernateImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.CompoundObjectPropertyTemplate
        // implement the user-visible interface
        public Zetbox.App.Test.TestPhoneCompoundObject Value
        {
            get { return ValueImpl; }
            set { ValueImpl = (Zetbox.App.Test.TestPhoneCompoundObjectNHibernateImpl)value; }
        }

        /// <summary>backing property for Value, takes care of attaching/detaching the values</summary>
		[System.Runtime.Serialization.IgnoreDataMember]
        public Zetbox.App.Test.TestPhoneCompoundObjectNHibernateImpl ValueImpl
        {
            get
            {
                return this.Proxy.Value;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (value == null)
                    throw new ArgumentNullException("value");
                if (!object.Equals(this.Proxy.Value, value))
                {
                    var __oldValue = this.Proxy.Value;
                    var __newValue = value;

                    NotifyPropertyChanging("Value", __oldValue, __newValue);

                    if (this.Proxy.Value != null)
                    {
                        this.Proxy.Value.DetachFromObject(this, "Value");
                    }
                    __newValue = (Zetbox.App.Test.TestPhoneCompoundObjectNHibernateImpl)__newValue.Clone();
                    this.Proxy.Value = __newValue;
                    this.Proxy.Value.AttachToObject(this, "Value");

                    NotifyPropertyChanged("Value", __oldValue, __newValue);
                    if(IsAttached) UpdateChangedInfo = true;
                }
            }
        }
        // END Zetbox.DalProvider.NHibernate.Generator.Templates.Properties.CompoundObjectPropertyTemplate        // BEGIN Zetbox.Generator.Templates.Properties.DelegatingProperty
        public object ValueObject
        {
            get { return Value; }
            set { Value = (Zetbox.App.Test.TestPhoneCompoundObjectNHibernateImpl)value; }
        }
        // END Zetbox.Generator.Templates.Properties.DelegatingProperty

        #region Serializer


        public override void ToStream(Zetbox.API.ZetboxStreamWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            // it may be only an empty shell to stand-in for unreadable data
            if (!CurrentAccessRights.HasReadRights()) return;
            binStream.Write(this.Proxy.Parent != null ? OurContext.GetIdFromProxy(this.Proxy.Parent) : (int?)null);
            binStream.Write(this.Value);
        }

        public override IEnumerable<IPersistenceObject> FromStream(Zetbox.API.ZetboxStreamReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            // it may be only an empty shell to stand-in for unreadable data
            if (CurrentAccessRights != Zetbox.API.AccessRights.None) {
            binStream.Read(out this._fk_Parent);
            {
                // use backing store to avoid notifications
                this.ValueImpl = binStream.ReadCompoundObject<Zetbox.App.Test.TestPhoneCompoundObjectNHibernateImpl>();
                this.ValueImpl.AttachToObject(this, "Value");
            }
            } // if (CurrentAccessRights != Zetbox.API.AccessRights.None)
            return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(TestCustomObject_PhoneNumbersOther_CollectionEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (TestCustomObject_PhoneNumbersOther_CollectionEntryNHibernateImpl)obj;
            var me = (TestCustomObject_PhoneNumbersOther_CollectionEntryNHibernateImpl)this;

            me._fk_Parent = other._fk_Parent;
            if (me.Value == null && other.Value != null) {
                me.Value = (Zetbox.App.Test.TestPhoneCompoundObject)other.Value.Clone();
            } else if (me.Value != null && other.Value == null) {
                me.Value = null;
            } else if (me.Value != null && other.Value != null) {
                me.Value.ApplyChangesFrom(other.Value);
            }
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_Parent.HasValue)
                this.Parent = ((Zetbox.App.Test.TestCustomObjectNHibernateImpl)OurContext.FindPersistenceObject<Zetbox.App.Test.TestCustomObject>(_fk_Parent.Value));
            else
                this.Parent = null;

        }


        public override void UpdateParent(string propertyName, IDataObject parentObj)
        {
            switch(propertyName)
            {
                case "Parent":
                    {
                        var __oldValue = (Zetbox.App.Test.TestCustomObjectNHibernateImpl)OurContext.AttachAndWrap(this.Proxy.Parent);
                        var __newValue = (Zetbox.App.Test.TestCustomObjectNHibernateImpl)parentObj;
                        NotifyPropertyChanging("Parent", __oldValue, __newValue);
                        this.Proxy.Parent = __newValue == null ? null : __newValue.Proxy;
                        NotifyPropertyChanged("Parent", __oldValue, __newValue);
                    }
                    break;
                default:
                    base.UpdateParent(propertyName, parentObj);
                    break;
            }
        }
        public override void SaveOrUpdateTo(NHibernate.ISession session)
        {
            // ValueCollectionEntries and CompoundCollectionEntries are saved by cascade
            //base.SaveOrUpdateTo(session);
        }


        public override void NotifyDeleting()
        {
            base.NotifyDeleting();

            // Follow Parent
            if (this.Parent != null && this.Parent.ObjectState == DataObjectState.Deleted)
            {
                ParentsToDelete.Add((NHibernatePersistenceObject)this.Parent);
                ((NHibernatePersistenceObject)this.Parent).ChildrenToDelete.Add(this);
            }

            // reset pointers on being deleted
            // this must happen after registering them above in ParentsToDelete/ChildrenToDelete to avoid interference from a second notification round
            this.Parent = null;
        }

        public class TestCustomObject_PhoneNumbersOther_CollectionEntryProxy
            : IProxyObject, ISortKey<int>
        {
            public TestCustomObject_PhoneNumbersOther_CollectionEntryProxy()
            {
            }

            public virtual int ID { get; set; }

            public virtual Type ZetboxWrapper { get { return typeof(TestCustomObject_PhoneNumbersOther_CollectionEntryNHibernateImpl); } }
            public virtual Type ZetboxProxy { get { return typeof(TestCustomObject_PhoneNumbersOther_CollectionEntryProxy); } }

            public virtual Zetbox.App.Test.TestCustomObjectNHibernateImpl.TestCustomObjectProxy Parent { get; set; }

            public virtual bool ValueIsNull { get; set; }

            public virtual Zetbox.App.Test.TestPhoneCompoundObjectNHibernateImpl Value { get; set; }


			[System.Runtime.Serialization.IgnoreDataMember]
			int ISortKey<int>.InternalSortKey { get { return ID; } }
        }

        // make proxy available for the provider
        [System.Runtime.Serialization.IgnoreDataMember]
        public override IProxyObject NHibernateProxy { get { return Proxy; } }    }
    // END Zetbox.DalProvider.NHibernate.Generator.Templates.CollectionEntries.ValueCollectionEntry
}
