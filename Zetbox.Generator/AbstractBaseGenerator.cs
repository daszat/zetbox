// This file is part of zetbox.
//
// Zetbox is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation, either version 3 of
// the License, or (at your option) any later version.
//
// Zetbox is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with zetbox.  If not, see <http://www.gnu.org/licenses/>.
namespace Zetbox.Generator
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Text;
    using Zetbox.API;
    using Zetbox.API.Server;
    using Zetbox.API.Utils;
    using Zetbox.App.Base;

    public abstract class AbstractBaseGenerator
    {
        private readonly static log4net.ILog Log = log4net.LogManager.GetLogger(typeof(AbstractBaseGenerator));

        private readonly IEnumerable<ISchemaProvider> _schemaProviders;
        protected IEnumerable<ISchemaProvider> SchemaProviders
        {
            get { return _schemaProviders; }
        }

        protected AbstractBaseGenerator(IEnumerable<ISchemaProvider> schemaProviders)
        {
            _schemaProviders = schemaProviders;
        }

        // Case #1382?
        protected string CodeBasePath { get; private set; }

        private Compiler _compiler;
        public virtual void Generate(Zetbox.API.IZetboxContext ctx, string basePath, Compiler compiler)
        {
            using (Log.InfoTraceMethodCall("Generate", "Generating " + this.BaseName))
            {
                _compiler = compiler;
                InitCodeBasePath(basePath);
                Directory.CreateDirectory(CodeBasePath);
                DeleteOldFiles();

                SaveKeyFile();

                var generatedFileNames = new List<string>();

                generatedFileNames.AddRange(Generate_Objects(ctx));

                Log.Info("  Assemblyinfo");
                generatedFileNames.Add(Generate_AssemblyInfo(ctx));

                Log.Info("  Other Files");
                generatedFileNames.AddRange(Generate_Other(ctx));

                Log.Info("  Project File");
                Generate_ProjectFile(ctx, ProjectGuid, generatedFileNames, _schemaProviders);
            }
        }

        protected virtual void SaveKeyFile()
        {
            // Save KeyFile
            using (var snkSrc = typeof(AbstractBaseGenerator).Assembly.GetManifestResourceStream("Zetbox.Generator.Zetbox.Objects.snk"))
            using (var snkDest = File.Open(Path.Combine(CodeBasePath, "Zetbox.Objects.snk"), FileMode.Create))
            {
                snkDest.SetLength(0);
                snkSrc.CopyAllTo(snkDest);
            }
        }

        protected virtual void DeleteOldFiles()
        {
            Directory.GetFiles(CodeBasePath, "*.*", SearchOption.AllDirectories)
                .ToList().ForEach(f => File.Delete(f));
            Directory.GetDirectories(CodeBasePath, "*.*", SearchOption.AllDirectories).OrderByDescending(s => s.Length)
                .ToList().ForEach(d => Directory.Delete(d));
        }

        protected virtual void InitCodeBasePath(string basePath)
        {
            // Case #1382?
            CodeBasePath = Path.Combine(basePath, TargetNameSpace);
        }

        public const int COMPILE_ORDER_Interface = 1;
        public const int COMPILE_ORDER_Implementation = 10;
        public const int COMPILE_ORDER_Other = 20;

        /// <summary>
        /// Order of compiling
        /// </summary>
        public abstract int CompileOrder { get; }

        /// <summary>
        /// A short string describing the generator for logfiles and namespaces.
        /// </summary>
        public abstract string Description { get; }

        /// <summary>
        /// the namespace where to lookup the templates of this provider
        /// </summary>
        public virtual string TemplateProviderNamespace { get { return this.GetType().Namespace + ".Templates"; } }

        /// <summary>
        /// the assembly where to lookup the templates of this provider
        /// </summary>
        public string TemplateProviderAssembly { get { return this.GetType().Assembly.FullName; } }

        /// <summary>
        /// A extra suffix added to all class names, to allow distinguish them when debugging.
        /// </summary>
        public abstract string ExtraSuffix { get; }

        /// <summary>
        /// The namespace which is generated by this provider
        /// </summary>
        public abstract string TargetNameSpace { get; }

        /// <summary>
        /// A short, descriptive string to put into all generated filenames
        /// </summary>
        /// Used as a safety fallback to avoid clashes between files and help orientation
        public abstract string BaseName { get; }

        /// <summary>
        /// Kludge to integrate well into the .sln, in "Registry Format"
        /// </summary>
        public abstract string ProjectGuid { get; }

        /// <summary>
        /// The name of the generated MsBuild project file.
        /// </summary>
        public string ProjectFileName { get { return TargetNameSpace + ".csproj"; } }

        /// <summary>
        /// The type name of the custom PropertyDescriptor.
        /// </summary>
        public virtual string CustomPropertyDescriptorName { get { return "PropertyDescriptor" + ExtraSuffix + Zetbox.API.Helper.ImplementationSuffix; } }

        /// <summary>
        /// List of aditional build targets, executed after all default targets has been build
        /// </summary>
        public virtual IEnumerable<string> AdditionalTargets { get { return new string[] { }; } }

        /// <summary>
        /// Required Namespaces for this project
        /// </summary>
        public abstract IEnumerable<string> RequiredNamespaces { get; }

        protected virtual string RunTemplateWithExtension(IZetboxContext ctx, string templateName, string targetFolder, string baseFilename, string extension, params object[] args)
        {
            string filename = String.Join(".", new string[] { baseFilename, BaseName, extension });
            if (!string.IsNullOrWhiteSpace(targetFolder))
            {
                filename = Path.Combine(targetFolder, filename);
            }
            return RunTemplate(ctx, templateName, filename, args);
        }

        protected virtual string RunTemplate(IZetboxContext ctx, string templateName, string filename, params object[] args)
        {
            try
            {
                filename = Unidecode(filename);
                var gen = new TemplateExecutor();

                gen.Settings.Add("basetemplatepath", "Zetbox.Generator.Templates");
                gen.Settings.Add("providertemplatenamespace", TemplateProviderNamespace);
                gen.Settings.Add("providertemplateassembly", TemplateProviderAssembly);

                gen.Settings.Add("template", templateName);

                gen.Settings.Add("targetdir", this.CodeBasePath);
                gen.Settings.Add("output", filename);
                gen.Settings.Add("logfile", "TemplateCodegenLog.txt");

                gen.Settings.Add("extrasuffix", ExtraSuffix);
                gen.Settings.Add("namespaces", String.Join(",", RequiredNamespaces.ToArray()));
                gen.Settings.Add("implementationnamespace", "Zetbox.DalProvider." + BaseName);

                gen.Settings.Add("propertydescriptorname", CustomPropertyDescriptorName);

                gen.Settings.Add("isfallback", _compiler.IsFallback.ToString());

                gen.TemplateParameters = new object[] { ctx }.Concat(args).ToArray();

                gen.ExecuteTemplate();

                return filename;
            }
            catch (Exception ex)
            {
                var msg = String.Format("Error while rendering template [{0}] to [{1}]", templateName, filename);
                Log.Error(msg, ex);
                throw new InvalidOperationException(msg, ex);
            }
        }

        private static readonly Dictionary<string, string> _transliterationTable = new Dictionary<string, string>() {
            { "ä", "ae" },
            { "Ä", "Ae" },
            { "ö", "oe" },
            { "Ö", "Oe" },
            { "ü", "ue" },
            { "Ü", "Ue" },
            { "ß", "sz" },
        };

        /// <summary>
        /// converts the string to ascii using transliteration. uses the _transliterationTable and a nice hack to reduce utf-8 to ASCII. probably works only with western characters.
        /// </summary>
        /// <remarks>See http://stackoverflow.com/questions/2173825/slugify-and-character-transliteration-in-c/2173922#2173922 </remarks>
        protected static string Unidecode(string filename)
        {
            foreach (var kvp in _transliterationTable)
            {
                filename = filename.Replace(kvp.Key, kvp.Value);
            }
            return Encoding.ASCII.GetString(Encoding.GetEncoding("Cyrillic").GetBytes(filename));
        }

        protected virtual string Generate_AssemblyInfo(IZetboxContext ctx)
        {
            return RunTemplateWithExtension(ctx, "AssemblyInfoTemplate", null, "AssemblyInfo", "cs");
        }

        protected virtual string Generate_ObjectClass(IZetboxContext ctx, ObjectClass objClass)
        {
            return RunTemplateWithExtension(ctx, "ObjectClasses.Template", objClass.Module.Name, objClass.Name, "Designer.cs", objClass);
        }

        protected virtual string Generate_CollectionEntries(IZetboxContext ctx)
        {
            return RunTemplateWithExtension(ctx, "ObjectClasses.CollectionEntries", null, "CollectionEntries", "Designer.cs");
        }

        protected virtual string Generate_Enumeration(IZetboxContext ctx, Enumeration e)
        {
            // only used on interface
            return null;
        }

        protected virtual string Generate_CompoundObject(IZetboxContext ctx, CompoundObject s)
        {
            return RunTemplateWithExtension(ctx, "CompoundObjects.Template", s.Module.Name, s.Name, "Designer.cs", s);
        }

        protected virtual string Generate_Interface(IZetboxContext ctx, Interface i)
        {
            // only used on interface
            return null;
        }

        protected virtual IEnumerable<string> Generate_Other(IZetboxContext ctx)
        {
            return new List<string>()
            {
                RunTemplateWithExtension(ctx, "Module", null, "Module", "cs", Description)
            };
        }

        protected virtual string Generate_ProjectFile(IZetboxContext ctx, string projectGuid, List<string> generatedFileNames, IEnumerable<ISchemaProvider> schemaProviders)
        {
            return RunTemplate(ctx, "ProjectFile",
                ProjectFileName,
                projectGuid,
                generatedFileNames.Where(s => !String.IsNullOrEmpty(s)).ToList(),
                schemaProviders);
        }

        protected virtual List<string> Generate_Objects(Zetbox.API.IZetboxContext ctx)
        {
            var generatedFileNames = new List<string>();

            Log.Info("  Object Classes");
            foreach (ObjectClass objClass in _compiler.GetObjectClassList(ctx).OrderBy(x => x.Name).ToList())
            {
                generatedFileNames.Add(Generate_ObjectClass(ctx, objClass));
                Log.Debug("    " + objClass.Name);
            }

            Log.Info("  Collection Entries");
            generatedFileNames.Add(Generate_CollectionEntries(ctx));

            Log.Info("  Interfaces");
            foreach (Interface i in _compiler.GetInterfaceList(ctx).OrderBy(x => x.Name))
            {
                generatedFileNames.Add(Generate_Interface(ctx, i));
                Log.Debug("    " + i.Name);
            }

            Log.Info("  Enums");
            foreach (Enumeration e in _compiler.GetEnumList(ctx).OrderBy(x => x.Name))
            {
                generatedFileNames.Add(Generate_Enumeration(ctx, e));
                Log.Debug("    " + e.Name);
            }

            Log.Info("  CompoundObjects");
            foreach (CompoundObject s in _compiler.GetCompoundObjectList(ctx).OrderBy(x => x.Name))
            {
                generatedFileNames.Add(Generate_CompoundObject(ctx, s));
                Log.Debug("    " + s.Name);
            }

            return generatedFileNames;
        }
    }
}
